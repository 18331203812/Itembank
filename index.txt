//vue面试题
一.vue面试题;

框架
    1.mvvm 框架是什么
    Mvvm定义MVVM是Model-View-ViewModel的简写 即模型-视图-视图模型 模型 指的是后端传递的数据 视图 指的是所看到的
	页面  视图模型 mvvm模式的核心,它是连接view和model的桥梁 它有两个方向:
    一是将 模型  转化成 视图 即将后端传递的数据转化成所看到的页面 实现的方式是:数据绑定
    二是将 视图 转化成 模型, 即将所看到的页面转化成后端的数据 实现的方式是:DOM 事件监听 这两个方向都实现的,我们称之为数
	据的双向绑定
    总结:在MVVM的框架下视图和模型是不能直接通信的 它们通过ViewModel来通信,ViewModel通常要实现一个observer观察者,当数据发
	生变化,ViewModel能够监听到数据的这种变化,然后通知到对应的视图做自动更新,而当用户操作视图,ViewModel也能监听到视图的变化
	然后通知数据做改动,这实际上就实现了数据的双向绑定
    2.mvc 框架是什么
    MVC的定义:MVC是Model-View- Controller的简写 即模型-视图-控制器 M和V指的意思和MVVM中的M和V意思一样 C即Controller指的是
	页面业务逻辑 使用MVC的目的就是将M和V的代码分离  MVC是单向通信 也就是View跟Model,必须通过Controller来承上启下MVC
    MVVM的区别并不是VM完全取代了C ,ViewModel存在目的在于抽离Controller中展示的业务逻辑,而不是替代Controller,其它视图操作业
	务等还是应该放在Controller中实现 也就是说MVVM实现的是业务逻辑组件的重用

生命周期函数面试题
    1.什么是vue生命周期
        Vue实例有一个完整的生命周期,也就是从开始创建 初始化数据 编译模板 挂载DOM 渲染 一 更新 卸载等一系列过程
        (通俗话讲 就是Vue实例从创建到销毁的过程)
    2.vue生命周期的作用是什么
        它的生命周期中有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑
    3.vue生命周期总共有几个阶段
        它可以总共分为8个阶段 创建前/后, 载入前/后,更新前/后,销毁前/销毁后
    4.第一次页面加载会触发哪几个钩子
        第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
    5.简述每个周期具体适合哪些场景
        生命周期钩子的一些使用方法 : beforecreate : 可以在这加个loading事件,在加载实例时触发 created : 初始化完成时的事件写在
		这里,如在这结束loading事件,异步请求也适宜在这里调用 mounted : 挂载元素,获取到DOM节点 updated : 如果对数据统一处理,在
		这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom
    6.created和mounted的区别
        created:在模板渲染成html前调用,即通常初始化某些属性值,然后再渲染成视图
        mounted:在模板渲染成html后调用,通常是初始化页面完成后,再对html的dom节点进行一些需要的操作
    7.vue获取数据在哪个周期函数
        created

vue路由面试题
    1.vue-router 是什么? 它有哪些组件
        vue-router是Vue.js官方的路由插件,它和vue.js是深度集成的,适合用于构建单页面应用 vue的单页面应用是基于路由和组件的,路由
		用于设定访问路径,并将路径和组件映射起来 传统的页面应用 是用一些超链接来实现页面切换和跳转的 在vue-router单页面应用中
		,则是路径之间的切换,也就是组件的切换
    2. active-class 是哪个组件的属性?
        router-link
        设置 链接激活时使用的 CSS 类名 默认值可以通过路由的构造选项 linkActiveClass 来全局配置
    4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值
         创建组件 引入组件
         定义路由 path配置组件路径(动态路由加: /"内容" )
         实现路由跳转 router-link (加参数)
         this.$route.params
    5.vue-router 有哪几种导航钩子?
         全局导航钩子
            beforeEach
            beforeResolve
            afterEach
         某个路由独享的导航钩子
            beforeEnter
         路由组件上的导航钩子
            beforeRouteEnter
            beforeRouteUpdate (2.2 新增)
            beforeRouteLeave
    6.$route 和 $router 的区别
         this.$route相当于当前激活的路由对象 包含当前url解析得到的数据 可以从对象里获取一些数据,如name,path等
         this.$router是VueRouter的实例方法,当导航到不同url,可以使用this.$router.push方法,这个方法则会向history里面添加一条记
		 录,当点击浏览器回退按钮或者this.$router.back()就会回退之前的url
    7.vue-router响应路由参数的变化
         watch (监测变化) $route
         beforeRouteUpdate
    8.vue-router传参
         get方法 <router-link :to="{path:'/test',query: {name: id}}">跳转</router-link>
            接收值 this.$route.query.name
         post方法 <router-link :to="{path:'/test',push: {name: id}}">跳转</router-link>
            接收值 this.$route.query.name
         路由方法
             props:{name:{required:false,default:''}}
    9.vue-router的两种模式
         vue-router 默认 hash 模式,还有一种是history模式
         hash模式的工作原理是hashchange事件,可以在window监听hash的变化.我们在url后面随便添加一个#xx触发这个事件
         history模式把window.history对象打印出来可以看到里边提供的方法和记录长度
    10.vue-router实现路由懒加载(动态加载路由 )
        vue异步组件 component: resolve => require(['@/components/home'],resolve)
        es提案的import() const About = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/about')
        webpack的require,ensure() component: r => require.ensure([], () => r(require('@/components/home')), 'demo')

vue常见面试题
    1.vue是什么
        Vue是一个渐进式的javascript开发框架,通过组件的开发,最后进行组件的组合,合并组件形成页面
        自动化构建工具
        构造器(构造函数)
    2.vue优点
        组件化开发
        单页面路由
        丰富的Api方法
        双向的数据绑定
        单向数据流
        易于结合其他第三库
    3.vue父组件向子组件传递数据?
        父组件的data中定义值,引入并调用子组件,在引用的子组件的标签上通过v-bind指令给子组件传值,子组件通过在data中定义的
		props属性接收父组件传过来的值然后应用到子组件里
            子组件接受的父组件的值分为  引用类型和普通类型两种
            普通类型:字符串(String) 数字(Number) 布尔值(Boolean) 空(Null)
            引用类型:数组(Array) 对象(Object)
            其中,普通类型是可以在子组件中更改,不会影响其他兄弟子组件内同样调用的来自父组件的值
            但是,引用类型的值,当在子组件中修改后,父组件的也会修改
    4.子组件像父组件传递事件?
        this.$emit('message', '第一个参数', '第二个参数');
            message在父组件  <div @message="getMyEvent"></div>
    5.v-show和v-if指令的共同点和不同点
        v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点
        v-show只是在修改元素的css样式,也就是display的属性值,元素始终在Dom树上
    6.如何让CSS只在当前组件中起作用
        <style scoped></style>
    7.<keep-alive></keep-alive>的作用是什么?
        <keep-alive>是Vue的内置组件,能在组件切换过程中将状态保留在内存中,防止重复渲染DOM
        <keep-alive> 包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 和 <transition> 相似,<keep-alive>是一个抽象组
		件:它自身不会渲染一个 DOM 元素,也不会出现在父组件链中
    8.如何获取dom
        Vue提供的ref属性以及this.$refs即可实现
        <div ref='box'  v-on:click="changeText()">这是一个盒子</div>
        changeText: function() {
            this.$refs.box.innerHTML = "改变盒子的文字";
        }
    9.说出几种vue当中的指令和它的用法?
        v-if 判断是否隐藏
        v-show 控制的隐藏出现,只是将css属性设为了display:none 或block;
        v-for 进行列表和表格的渲染
        v-bind 绑定属性
        v-model 双向数据绑定
        v-html 获取html标签
        v-text不解释标签
    10.vue-loader是什么?使用它的用途有哪些?
        vue-loader是解析 .vue 文件的一个加载器,跟 template/js/style转换成 js 模块;
        用途:js可以写es6 style样式可以scss或less template可以加jade等
    11.为什么使用key
        vue中列表循环需加:key="唯一标识" 唯一标识可以是item里面id index等 ,		            			              因为vue组件高度复用增加Key可以标识组件的唯一性
		,为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM
    12.axios及安装
        npm install axios --save
    13.为什么要有跨域限制
        跨域:指的是浏览器不能执行其他网站的脚本 它是由浏览器的同源策略造成的,是浏览器对javascript施加的安全限制
        同源策略(Same origin policy)是一种约定,它是浏览器最核心也最基本的安全功能.如果缺少了同源策略,则浏览器的正常功能
		可能都会受到影响 可以说 Web 是构建在同源策略基础之上的,浏览器只是针对同源策略的一种实现
        因为存在浏览器同源策略,所以才会有跨域问题
    14.axios解决跨域
        首先在main.js中,配置下我们访问的Url前缀:Axios.defaults.baseURL = '/api';
        配置代理 : 修改config文件夹下的index.js文件，在proxyTable中加上如下代码:
            '/api':{
                target: "https://www.v2ex.com/api",
                    changeOrigin:true,
                    pathRewrite:{
                    '^/api':''
                }
            }
        修改请求Url:修改刚刚的axios请求，把url修改如下
        因为我们给url加上了前缀 /api，我们访问 http://127.0.0.1:19323/site/info.json 
		就当于访问了：http://127.0.0.1:19323/api/site/info.json。(假设本地访问端口号为 19323)
        又因为在 index.js 中的 proxyTable 中拦截了 /api ,并把 /api 及其前面的所有替换成了 target 中的内容，
		因此实际访问 Url 是https://www.v2ex.com/api/site/info.json。
	15.v-modal的使用
		(1).v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。
			你应该通过 JavaScript 在组件的 data 选项中声明初始值。
		(2).对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)
		(3).在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。
			你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步
		(4).如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符
	16.scss的安装以及使用
		less与scss部分功能是相同的，都可以简化样式的编写，但是在开发中发现，当希望通过函数处理某些数据的时候，
		无法定义数据的返回,而scss可以完成对数据运算后返回数据方法的定义，因此决定使用scss
		npm install -g sass
	17.请说出vue.cli项目中src目录每个文件夹和文件的用法？
		assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置；
		view视图；app.vue是一个应用主组件；main.js是入口文件.
	18.分别简述computed和watch的使用场景
		(1).watch和computed都是以Vue的依赖追踪机制为基础，它们都试图处理这样一件事情：当某一个数据（称它为依赖数据）
		发生变化的时候，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据的变动。
			methods用来定义函数，它需要手动调用才能执行，需要像”fuc()”这样去调用它（假设函数为fuc）.
			computed是计算属性，事实上和data对象里的数据属性是同一类的（使用上），在取值的时候，
			用this.fullName去取用，就和取data一样（不要当成函数调用！！）
		watch擅长处理的场景：一个数据影响多个数据 
		computed擅长处理的场景：一个数据受多个数据影响 
	19.v-on可以监听多个方法吗
		(1).<button @click="a(),b()">点我ab</button>
		(2).<button v-on="{mouseenter: onEnter,mouseleave: onLeave}">鼠标进来</button>
			<button @mouseenter="onEnter" @mouseleave="onLeave">鼠标进来</button>
		(3). v-on修饰符  .stop .prevent .capture .self 以及指定按键.{keyCode|keyAlias} 
			这里的.stop 和 .prevent也可以通过传入&event进行操作 
			全部按键别名有：enter tab delete esc space up down left right 
			<form @keyup.delete="onKeyup" @submit.prevent="onSubmit">
				<input type="text" placeholder="在这里按delete">
				<button type="submit">点我提交</button>
			</form>
	20.$nextTick的使用
		(1).为什么要使用$nextTick：这是由于Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，
		然后把在同一个事件循环 (event loop) 当中观察到数据变化的watcher推送进这个队列。如果这个watcher被触发多次，
		只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和dom操作。而在下一个事件循环开始时，
		Vue会进行必要的dom更新，并清空队列（$nextTick方法就相当于在dom更新和清空队列后额外插入的执行步骤）
		(2).$nextTick是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
	21.vue组件中data为什么必须是一个函数
		如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，
		让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，
		就会造成一个变了全都会变的结果。
	22.vue事件对象的使用
		v-on:click 简写@click 阻止冒泡@click.stop
	23.组件间的通信
		父组件向子组件传递数据通过设置标签的属性传递数据，在子组件用props接受
		子组件向父组件传递数据 this.$emit("titleChanged","子向父组件传值");
	24.渐进式框架的理解
		在我看来，渐进式代表的含义是：主张最少。
		每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。
		比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：
		- 必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）

		所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。

		比如React，它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。

		Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。
		渐进式的含义，我的理解是：没有多做职责之外的事。
	25.Vue中双向数据绑定是如何实现的
		VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设
		置属性值(set)的操作来实现的。
	26.单页面应用和多页面应用区别及优缺点
		单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。
		所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，
		单页面的页面跳转，仅刷新局部资源。多应用于pc端。
			单页面的优点：
			1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小
			2，前后端分离
			3，页面效果会比较炫酷（比如切换页面内容时的专场动画）
		多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新
			单页面缺点：
			1，不利于seo
			2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，
			所以需要自己建立堆栈管理）
			3，初次加载时耗时多
			4，页面复杂度提高很多
	27.vue中过滤器有什么作用及详解
		过滤器分为全局过滤器和本地过滤器,全局过滤器顾名思义就是所有Vue实例挂载的元素内都能使用，
		而本地过滤器则是指只有过滤器函数所在的Vue实例挂载的元素内可以使用
			全局过滤器：
			Vue.filter('Upper',function (name) {
					return name.toUpperCase();
			});
			本地过滤器：
			  var vm=new Vue({
					el: '#app',
					data: {
						name:'martin'
					},
					filters:{
						Upper:function (name) {
							return name.toUpperCase()
						}
					}
				})
	28.v-if和v-for的优先级
		永远不要把 v-if 和 v-for 同时用在同一个元素上。
		当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级
	29.assets和static的区别
		相同点：
			assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，
			这是相同点 
		不相同点：
		(1).assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，
		所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html
		一同上传至服务器
		(2).static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。
		因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static中的资源文件由于没有进行压缩等操作，
		所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大的空间。所以简单点使用建议如下：
		(3).将项目中template需要的样式文件js文件等都可以放置在assets中，走打包这一流程。减少体积。
		而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，
		我们不再需要处理，直接上传。
	30.列举常用的指令
		插入文本:v-text
		插入HMTL:v-html
		循环:v-for
		绑定事件:v-on
		双向绑定:v-model
		属性绑定:v-bind
		条件渲染:v-show 是否隐藏元素
		条件渲染:if ... else if ...else型
	31.vue常用的修饰符
		1.事件修饰符
			.stop 阻止冒泡
			.prevent 防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）
			.capture 与事件冒泡的方向相反，事件捕获由外到内,捕获事件：嵌套两三层父子关系，然后所有都有点击事件，点击子节点，
				就会触发从外至内 父节点-》子节点的点击事件
			.self 只会触发自己范围内的事件，不包含子元素
			.once 只执行一次
		2.键盘修饰符
			.enter：回车键
			.tab：制表键
			.delete：含delete和backspace键
			.esc：返回键
			.space: 空格键
			.up：向上键
			.down：向下键
			.left：向左键
			.right：向右键
		3.自定义按键修饰符别名
			在Vue中可以通过config.keyCodes自定义按键修饰符别名。
			 <input type="text" @keyup.f5="prompt()" />按下F5，会触发prompt方法
		4.修饰符
			.lazy在改变后才触发（也就是说只有光标离开input输入框的时候值才会改变）
			.number将输出字符串转为Number类型・（虽然type类型定义了是number类型，但是如果输入字符串，输出的是string）
			.trim自动过滤用户输入的首尾空格
	32.数组更新检测 (由于 Javascript 的限制，Vue 不能检测到以下变动的数组：)
		Vue包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：
			push()
			pop()
			shift()
			unshift()
			splice()
			sort()
			reserve()
		替换数组
			例如： filter(), concat() 和 slice() 。这些方法不会改变原始数组，但总是会返回一个新数组。
	33.Vue.set视图更新
		this.$set()和Vue.set()本质方法一样，前者可以用在methods中使用。set方法调用时，可以触发页面全部重新渲染。
	34.自定义指令详解
		Vue.directive自定义指令
		自定义指令中传递的三个参数
			el: 指令所绑定的元素，可以用来直接操作DOM。
			binding:  一个对象，包含指令的很多信息。
			vnode: Vue编译生成的虚拟节点。
		自定义指令的生命周期
			bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。
			inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。
			update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，
				可以忽略不必要的模板更新。
			componentUpdated:被绑定元素所在模板完成一次更新周期时调用。
			unbind:只调用一次，指令与元素解绑时调用。
	35.vue的两个核心点
		Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动、组件系统。
			数据驱动：
				Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter
				（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。
			组件系统：
				应用类UI可以看作全部是由组件树构成的。
	36.vue和jQuery的区别
		(1).jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，
		其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。
		比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。 
		(2).Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象
		，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。
	37.引进组件的步骤
		1.在template中引入组件
		2.在script的第一行用import引入路径
		3.用component中写上组件名称
	38.Vue-cli打包命令是什么？打包后悔导致路径问题，应该在哪里修改
		命令行输入：npm  run  build
			到config文件夹中打开index.js文件
			assetsPublicPath属性作用是指定编译发布的根目录，‘/’指的是项目的根目录 ，’./’指的是当前目录。
	39.	三大框架的对比
						Angular		React		Vue
			组织方式	MVC			模块化		模块化
			数据绑定	双向绑定	单向绑定	双向绑定
			模板能力	强大		自由		自由
			自由度		较小		大			较大
			路由		静态路由	动态路由	动态路由
	40.跨组件双向数据绑定
		父子组件之间的数据传递
		对象的引用关系() 该方法运用的是对象的引用关系，来实现的。
		 .sync   this.$emit('update:name',this.newName);
		v-model (模仿v-model)
			newValue: {
				get:function() {
				return this.value; 
				},
				set:function(value) {
				this.$emit('input', value);
				}
			}
	41.delete和Vue.delete删除数组的区别
		delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
		Vue.delete 直接删除了数组 改变了数组的键值。
	42.Vue-router跳转和location.href有什么区别
		<router-link> 比起写死的 <a href="..."> 会好一些，
		理由如下：无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，
		或者在 IE9 降级使用 hash 模式，无须作任何变动。在 HTML5 history 模式下，router-link 会守卫点击事件，
		让浏览器不再重新加载页面。当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。
	43. vue slot
		是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑
		（替换组件模板中<slot> 位置），当插槽也就是坑<slot name=”mySlot”>有命名时，
		组件标签中使用属性slot=”mySlot”的元素就会替换该对应位置内容；
		
		简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，
		就是slot分发负责的活。
	44.你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？
		根据vue-cli脚手架规范，一个js文件，一个CSS文件。
	45.axios的特点有哪些
		axios是一个基于promise的HTTP库，支持promise的所有API；
		它可以拦截请求和响应；
		它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据；
		它安全性更高，客户端支持防御XSRF；
	46.请说下封装 vue 组件的过程？
		首先，使用Vue.extend()创建一个组件
		然后，使用Vue.component()方法注册组件
		接着，如果子组件需要数据，可以在props中接受定义
 		最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
	47.vue 各种组件通信方法（父子 子父 兄弟 爷孙 毫无关系的组件）
		父子:组件的props属性用于接收父组件传递的信息. 
		子父:而子组件想要向父组件传递信息, 可以使用$emit事件
		爷孙:它们可以分解为两个父子组件通信
		兄弟:兄弟组件通信即组件之间通信. 这就要用到观察者模式了. 因为vue实例的原型全部来自Vue.prototype.
			那么我们就可以了将事件中心绑定到Vue.prototype的某个属性上 
			let bus = new Vue()
			Vue.prototype.bus = bus
			this.bus.$on('send', (msg)=> {
			  this.msg = (msg)
			})
			//函数
			toUp() {
			  this.bus.$emit('send', 'down来消息了')
			}
	48.params和query的区别
		query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
		注意接收参数的时候，已经是$route而不是$router了哦！！
		query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
	49.vue初始化页面闪动问题
		v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。
		v-text vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
	50.vue更新数组时触发视图更新的方法
		push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
		pop() 方法用于删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。
		shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。
		unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
		splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组。
		sort() 方法用于对数组的元素进行排序。
		reverse() 方法用于颠倒数组中元素的顺序。
		Vue.set() 响应式新增与修改数据
	51.vue常用的UI组件库
		 iView UI组件库 (https://www.iviewui.com/)
		 Vux UI组件库 (https://vux.li/)
		 Element UI组件库 (http://element.eleme.io/#/zh-CN)
		 Mint UI组件库 (http://mint-ui.github.io/#!/zh-cn)
		 Bootstrap-Vue UI组件库 (https://bootstrap-vue.js.org/)
		 Ant Design Vue UI组件库 (https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/)
		 AT-UI UI组件库 (https://at-ui.github.io/at-ui/#/zh)
		 Vant UI组件库 (https://youzan.github.io/vant/#/zh-CN/intro)
		 cube-ui UI组件库 (https://didi.github.io/cube-ui/#/zh-CN)
		 Muse-UI UI组件库 (https://muse-ui.org/#/zh-CN)
		 N3-components UI组件库 (https://n3-components.github.io/N3-components/component.html)
		 Mand Mobile(https://didi.github.io/mand-mobile/#/zh-CN/home)
	52.vue如何引进本地背景图片
		vue在data引入本地图片(在img元素中用：src绑定地址的)
		直接在CSS样式中引用的
	53. vue如何引进sass
		安装sass的依赖包 (npm install --save-dev sass-loader)
		进入build文件，在webpack.base.config.js中module.rules配置
		修改components目录中的Hello.vue文件的style标签 (<style lang='scss'><style>)
	54.vue修改打包后静态资源路径的修改
		我们只需要修改编译后的环境，所以只要修改prod.env.js下的build属性下的assetsPublicPath属性
		默认值是 "/" 根目录
		我这里加了一级 "/mywebsite/"
		最终页面上请求到的静态资源路径，比如css文件的地址就是：
		http://www.***.cn/mywebsite/static/css/index****.css

vuex常见面试题
	1.vuex是什么？怎么使用？哪种功能场景使用它？
		vue框架中状态管理。
		在main.js引入store，注入。
		场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
	2.vuex有哪几种属性
		state => 基本数据 
		getters => 从基本数据派生的数据 
		mutations => 提交更改数据的方法，同步！ 
		actions => 像一个装饰器，包裹mutations，使之可以异步。 
		modules => 模块化Vuex
	3.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
		如果您使用vuex的话，建议您存入vuex中，因为actions可以执行异步操作。同上，简单的页面放在methods里面即可。
		比较复杂，或者重要建议放在vuex中，容易维护，代码清晰,并且调用简单，这个在项目后期很重要。
	4.Vuex中如何异步修改状态
		在调用vuex中的方法action的时候，用promise实现异步修改
	5.Vuex中actions和mutations的区别
		action主要处理的是异步的操作，mutation必须同步执行，而action就不受这样的限制，也就是说action中我们既可以处理同步，
		也可以处理异步的操作
		action改变状态，最后是通过提交mutation

二.ES6面试题
	
ES6新增方法面试题
	1.let const var比较
		var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
		let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
		const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。
		(全局作用域 函数作用域 块级作用域)
	2.反引号（`）标识
		普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
	3.函数默认参数
		 var f = function (a = 10,b = 10,c = 2a+b) {
            console.log(a+b)
            console.log(c)
         };
		f();
	4.箭头函数
		箭头函数this为父作用域的this，不是调用时的this
		箭头函数不能作为构造函数，不能使用new
		箭头函数返回对象时，要加一个小括号
		箭头函数没有arguments，caller，callee
		箭头函数通过call和apply调用，不会改变this指向，只会传入参数
		箭头函数没有原型属性
	5.属性简写
		同名的属性可以省略不写用"," 代替
	6.Object.keys()方法，获取对象的所有属性名或方法名
		用Object.keys()方法获取属性对应的值
		该方法可获得对象的属性名，返回一个数组
	7.import和export
		import语句用于导入由另一个模块导出的绑定。	
		用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，一边其他程序可以通过import语句使用它们。
	8.Promise对象
		promise是异步编程的一种解决方法。
		是一个构造函数，这个构造函数里有两个参数，分别是：resolve（成功之后的回调函数）、reject（失败之后的回调函数）。
		Pending：进行中
		Resolved(Fulfilled)：已完成
		Rejected：已失败
		所谓promise，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，
		从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，
		各种异步操作都可以用同样的方法进行处理。
	9.解构赋值
		let [a, b, c] = [1, 2, 3] // a=1, b=2, c=3
		let {a, b} = {a: 'aaaa', b: 'bbbb'} // a='aaaa' b='bbbb'
	10.set数据结构（可用于快速去重）
		类似于数组，但是成员的值都是唯一的，没有重复。Set本身是一个构造函数，用来生成Set数据结构
		const s = new Set();
		[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
	11.Spread Operator 展开运算符(...)
		(1).组装对象或者数组
			//数组
			const color = [ 'red' , 'yellow' ]
			const colorful = [...color, 'green' , 'pink' ]
			console.log(colorful)

			//对象
			const alp = { first:'a',second:'b' }
			const alphabets = { ...alp,third: 'c'}
			
ES6数组面试题
	1.forEach()
		forEach():遍历数组,并为每个元素调用传入的函数; 举例:
	2.map()
		方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
	3.filter()
		判断数组中是否存在某个值 方法返回一个新数组，
	4.reduce()
		reduce() 方法接收一个函数作为累加器,reduce 为数组中的每一个元素依次执行回调函数，
		不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组 
	5.some()
		方法用于检测数组中的元素是否满足指定条件（函数提供）。
		some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。
	6.every()
		方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。
		every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。
	7.all()方法
		Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

js面试题
	1.简述同步和异步的区别
		(1).同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。
		当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。
		(2).异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。
	3.Javascript中的七种主要数据类型
		Number、string、Object、Array、Boolean Null、Undefined
	3.如何判断数据类型
		typeof 
		console.log(
			typeof 123, //"number"
			typeof 'dsfsf', //"string"
			typeof false, //"boolean"
			typeof [1,2,3], //"object"
			typeof {a:1,b:2,c:3}, //"object"
			typeof function(){console.log('aaa');}, //"function"
			typeof undefined, //"undefined"
			typeof null, //"object"
			typeof new Date(), //"object"
			typeof /^[a-zA-Z]{5,20}$/, //"object"
			typeof new Error() //"object"
		);
	4.Js的事件委托是什么，原理是什么
		事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件
		优点： 1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。
				2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。
				3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。
		利用冒泡的原理，把事件加到父级上，触发执行效果。
	5.如何改变函数内部的this指针的指向
		(1).如果一个函数，是某个对象的key 值，那么，this就指向这个对象。 
		(2).如果函数new 了一下，那么就会创建一个对象，并且this 指向 新创建的对象。 
		(3).通过apply 可以改变this 的指向 
		javascript 的this 可以简单的认为是 后期绑定，没有地方绑定的时候，默认绑定window。 
	6.列举几种解决跨域问题的方式，且说明原理
		跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
		(1).JSONP
			通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，
			在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，
			我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
			jsonp缺点：只能实现get一种请求。
		(2).代理
			服务器代理
		(3).PHP端修改header（XHR2方式）
	7.哪些操作会造成内存泄露？
		内存泄漏是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
		1.意外的全局变量引起的内存泄露
		2.闭包引起的内存泄露
		3.没有清理的DOM元素引用
		4.被遗忘的定时器或者回调
		5.子元素存在引起的内存泄露
		6.IE7/8引用计数使用循环引用产生的问题
	8.谈谈垃圾回收机制的方式及内存管理
		垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。
		JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，
		因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。
		合理的GC方案
		遍历所有可访问的对象。
		回收已不可访问的对象。
		和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑
	9.js实现继承的方法有哪些
		(1).es6中的继承使用Class来创建对象
		(2).原型式继承 :原型式继承主要的借助原型可以基于已有的对象创建新的对象，基本思想就是创建一个临时性的构造函数，
			然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例
		(3).借用构造函数 :子类型构造函数的内部调用超类型构造函数 该方法主要是通过apply()和call()方法
		(4).原型链继承:
	10.判断一个变量是否是数组，有哪些办法
		instanceof
		Array对象的 isArray方法
		Object.prototype.toString
	11.箭头函数与普通函数有什么区别
		相比普通函数更简洁的语法
		没有this
		不能使用new
		不绑定arguments，用rest参数...解决
		使用call()和apply()调用
		捕获其所在上下文的 this 值，作为自己的 this 值
		箭头函数没有原型属性
		不能简单返回对象字面量
		箭头函数不能当做Generator函数,不能使用yield关键字
		箭头函数不能换行
	12.new操作符具体干了什么
		(1).先创建了一个新的空对象
		(2).然后让这个空对象的__proto__指向函数的原型prototype
		(3).将对象作为函数的this传进去，如果return 出来东西是对象的话就直接返回 return 的内容，没有的话就返回创建的这个对象
	13.Ajax原理
		Ajax的工作原理相当于在用户和服务器之间加了―个中间层，使用户操作与服务器响应异步化。
		这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担，
		从而达到节约ISP的空间及带宽租用成本的目的。
		Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。
		简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。
	14.模块化开发怎么做
		全局函数
		对象封装--命名空间 
		私有公有成员分离
		模块的扩展与维护
	15.异步加载Js的方式有哪些
		异步加载又被称为非阻塞加载，浏览器在下载JS的同时，还会进行后续页面处理。
		Script Dom Element
		onload时的异步加载
		$(document).ready()
		<script>标签的async="async"属性
		<script>标签的defer="defer"属性
	16.xml和 json的区别
		xml扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、
		定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。
		JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。
		可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式
	17.webpack如何实现打包的
		webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。
		并不是什么commonjs或者amd之类的模块化规范。webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。
		至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。
		webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，
		所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)
	18.用过哪些设计模式
		MVC模式,在J2EE项目开发中主要用在表示层框架中，很好解决视图和流程控制。在项目中采用的Struts、WebWork等框架。
		DAO模式,在项目开发中主要用在数据层，封装数据的访问操作，为业务层提供数据服务。
		IoC模式,在项目开发中业务层有大量对象，他们之间存在依赖关系，可以使用IoC模式减少他们之间的代码耦合，
			提高系统的可扩展性。实际项目中使用的Spring框架来实现业务组件的装配。
		Observer模式，在Servlet的监听器中应用到了观察者模式。
		singleton单例模式和Factory工厂模式结合使用在项目中无需使用者了解过多的细节就可获取有关的对象实例。
			比如Hibernate项目中通过SessionFactory来获取Session。
		bridge模式，在项目中使用JDBC驱动访问数据库。
	19.为什么要同源限制
		同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。
		它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
		这里的同源指的是：同协议，同域名和同端口。
		在普通的Javascript应用中，我们可以修改Frame的href，或者IFrame的src，以实现GET方式的跨域提交，
		但是却不能访问跨域的Frame/IFrame中的内容。
	20.javascript有哪些方法定义对象
		基于已有对象扩充其属性和方法
		工厂方式new Object();
		构造函数方式this.username = "zhangsan";
		原型(“prototype”)方式
		动态原型方式 在构造函数中通过标志量让所有对象共享一个方法，而每个对象拥有自己的属性。
	21.说说你对promise的了解
		Promise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决 方案（回调函数和事件）更合理和更强大。 
		Promise对象的状态不受外界影响，有3个状态： 
			1）pending 初始状态 
			2）fulfilled 成功状态 
			3）rejected 失败状态
		Promise的状态一旦改变，就不会再变。 
		Promise,一旦新建，它就会立即执行，无法中途取消。 
		Promise如果不设置回调函数，Promise内部就会报错，不会反映到外部。 
		当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成。
	22.介绍js有哪些内置对象？
		Arguments 函数参数集合
		Array 数组
		Boolean 布尔对象
		Date 日期时间
		Error 异常对象
		Function 函数构造器
		Math 数学对象
		Number 数值对象
		Object 基础对象
		RegExp 正则表达式对象
		String 字符串对象
	23.说几条写JavaScript的基本规范？
		1.减少全局污染
		2.变量名的提升，应该在函数内部中所有使用var声明的变量都会提升到函数体头部。以免造成不必要的错误。
		3.for循环
			我们经常会把for()循环写成这种形式的。
			for(var i=0,;i<myarray.length;i++) 其实呢dom遍历是需要时间的，如果我们在数据很多的情况下也这样子写的话，
			这样子网页的性能就会变差，所以我们应该重复循环使用的是一开始遍历得到的结果myarray.length，
			把它保存在一个变量中，这样子我们就可以不用循环遍历再次进行操作了。
			for(var i=0,max=myarray.length;i<max;i++)
		4.用“===”取代"=="，前者是严格相等的意思，连数据类型也是需要相比较的，而后者提前会进行隐式的类型转换。
		5.花括号｛｝
			我们如果使用了for循环或者是if语句的话，我们都应该使用｛｝，即使是if后面的语句只有一行，我们也应该要使用｛｝。
		6.命名规则
			构造器函数首字母大写，如function Person(){}
		7.写注释。
		8.不要在同一个行内声明多个变量。
		9.Switch语句中必须带有default分支，
	24.eval是做什么的？
		把字符串参数解析成JS代码并运行，并返回执行的结果；	
	25.null 和undefined的区别？
		null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。
		undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。
	26.js延迟加载的方式有哪些？
		defer 属性 <script src="test1.js" defer="defer"></script>
		async 属性	<script src="test1.js" async></script>
		动态创建DOM方式: 这些代码应被放置在</body>标签前(接近HTML文件底部)
		使用jQuery的getScript方法
		使用setTimeout延迟方法
		让JS最后加载
	27.说说严格模式的限制
		变量必须声明后再使用
		函数的参数不能有同名属性，否则报错
		不能使用with语句
		不能对只读属性赋值，否则报错
		不能使用前缀0表示八进制数，否则报错
		不能删除不可删除的属性，否则报错
		不能删除变量delete prop，会报错，只能删除属性delete global[prop]
		eval不会在它的外层作用域引入变量
		eval和arguments不能被重新赋值
		arguments不会自动反映函数参数的变化
		不能使用arguments.callee
		不能使用arguments.caller
		禁止this指向全局对象
		不能使用fn.caller和fn.arguments获取函数调用的堆栈
		增加了保留字（比如protected、static和interface）
		设立"严格模式"的目的，主要有以下几个：
		消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
		消除代码运行的一些不安全之处，保证代码运行的安全；
		提高编译器效率，增加运行速度；
	28.常见兼容性问题
		不同浏览器的标签默认的margin和padding不同
		设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度
		块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
		图片默认有间距
		标签最低高度设置min-height不兼容
		各种特殊样式的兼容，比如透明度、圆角、阴影等。特殊样式每个浏览器的代码区别很大，所以，
		只能现查资料通过给不同浏览器写不同的代码来解决。
	29.原始类型有哪几种？null是对象吗？
		undefined、null、string、number、boolean、symbol(es6新增)
		null其实并不是一个对象，尽管typeof null 输出的是object,但是这其实是一个bug。在js最初的版本中使用的是32位系统，
		为了性能考虑地位存储变量的类型信息，000开头表示为对象类型，然而null为全0，故而null被判断为对象类型。
	30.如何判断this？箭头函数的this是什么
		箭头函数：出现的作用除了让函数的书写变得很简洁，可读性很好外；最大的优点是解决了this执行环境所造成的一些问题。
		比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题。
		谁调用函数 谁就是this
	31.== 和 ===的区别
		== 表示相等 （值相等）
		===表示恒等（类型和值都要相等）
		js在比较的时候如果是 == 会先做类型转换，再判断值得大小，如果是===类型和值必须都相等。
	32.什么是闭包
		简单讲，闭包就是指有权访问另一个函数作用域中的变量的函数。
		它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。
		外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。
	33.JavaScript原型，原型链 ? 有什么特点？
		原型:JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。
		原型链:简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，
			原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，
			当向上找找到Object的原型的时候，这条原型链就算到头了。
	34.typeof()和instanceof()的用法区别
		typeof（） 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。
		instanceof 用于判断一个变量是否某个对象的实例，如var a=new Array();alert(a instanceof Array);
		会返回true，同时alert(a instanceof Object)也会返回true;这是因为Array是object的子类
	35.ES6新的特性有哪些？
		不一样的变量声明：const和let
		模板字符串
		箭头函数（Arrow Functions）
		函数的参数默认值
		Spread / Rest 操作符
		二进制和八进制字面量
		对象和数组解构
		对象超类
		for…of 和 for…in
		ES6中的类
	36.promise 有几种状态, Promise 有什么优缺点 ?
		* pending：初始状态，既不是成功也不是失败
		* fulfilled：意味着操作完全成功
		* rejected：意味着操作失败
		Promise对象的缺点：
		1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。
		2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
		3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
		4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。
		Promise对象的优点：
		promise主要解决回调地狱问题
		使得原本的多层级的嵌套代码，变成了链式调用
		让代码更清晰，减少嵌套数
	37.Promise构造函数是同步还是异步执行，then呢 ?promise如何实现then处理 ?
		异步执行
	38.Promise和setTimeout的区别 ?
		promise比settimeout先执行的
		原因：promise的任务会在当前事件循环末尾中执行，而settimeout中的任务是在下一次事件循环中执行。
		所以异步操作不是一个新事件添加到事件循环队列，而是就在当前任务队里末尾添加。
		这里的promise异步操作就添加到了当前任务队的末尾了，而settimeout则是下一个事件中的任务了。
	39.如何实现 Promise.all ?
		Promise.all()接收一个数组为参数，当数组的所有Promise都为resolve的状态时，Promise.all()才会成功；
		若有一个失败，都会被认为是失败的。
	40.如何实现 Promise.finally ?
		不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。
	41.如何判断img加载完成
		load事件
			$('img').onload = function() {
			//code
			}
		readystatechange事件
			img.onreadystatechange = function() {
				if(img.readyState=="complete"||img.readyState=="loaded"){ 
					p.innerHTML = 'readystatechange:loaded'
				}
			}
		img的complete属性
		function imgLoad(img, callback) {
			var timer = setInterval(function() {
				if (img.complete) {
					callback(img)
					clearInterval(timer)
				}
			}, 50)
			}
			imgLoad(img1, function() {
			p1.innerHTML('加载完毕')
		})
	42.如何阻止冒泡？
		// 阻止浏览器的默认行为
		window.event? window.event.returnValue=false :e.preventDefault();

		//停止事件冒泡
		window.event?window.event.cancelBubble=true:e.stopPropagation();
	43.ajax请求时，如何解释json数据
		json是一种轻量级交互格式,本质上都是字符串,常用于前后端的数据交互,本质上就是字符串.
		前端在解析后端发来的数据,使用JSON.parse()方法把字符串转为json对象.
		前端在向后端发送数据,使用JSON.stringify()方法把json对象转为字符串. 
	44. json和jsonp有什么差异？
		json返回的是一串数据；而jsonp返回的是脚本代码（包含一个函数调用）；
		JSON其实就是JavaScript中的一个对象，json其实就是JavaScript中的对象(Object)和数组(Array，其实也是对象)相互嵌套，
		以此模拟出许多复杂的数据结构。
		jsonp全名叫做json with padding，很形象，就是把json对象用符合js语法的形式包裹起来以使其它网站可以请求得到，
		也就是将json数据封装成js文件；
		json是理想的数据交换格式，但没办法跨域直接获取，于是就将json包裹(padding)在一个合法的js语句中作为js文件传过去。
		这就是json和jsonp的区别，json是想要的东西，jsonp是达到这个目的而普遍采用的一种方法，当然最终获得和处理的还是json。所以说json是目的，jsonp只是手段。json总会用到，而jsonp只有在跨域获取数据才会用到。
		json和jsonp虽然只有一个字母的区别，但是它们之间扯不上关系。 json是一种轻量级的数据交换格式。
		jsonp是一种跨域数据交互协议。 
		json的优点：（1）基于纯文本传递极其简单，（2）轻量级数据格式适合互联网传递，（3）容易编写和解析。
	45.浏览器是如何渲染页面的？
		处理HTML标记并构建DOM树
		处理CSS标记并构建CSSOM树
		将DOM与CSSOM合并成一个渲染树
		根据渲染树来布局，计算每个节点的布局信息
		将各个节点绘制到屏幕上
	46.XMLHttpRequest：XMLHttpRequest.readyState;状态码的意思
		1**	信息，服务器收到请求，需要请求者继续执行操作
		2**	成功，操作被成功接收并处理
		3**	重定向，需要进一步的操作以完成请求
		4**	客户端错误，请求包含语法错误或无法完成请求
		5**	服务器错误，服务器在处理请求的过程中发生了错误
	47.http请求的状态吗
		1**	信息，服务器收到请求，需要请求者继续执行操作
		2**	成功，操作被成功接收并处理
		3**	重定向，需要进一步的操作以完成请求
		4**	客户端错误，请求包含语法错误或无法完成请求
		5**	服务器错误，服务器在处理请求的过程中发生了错误
	48.document.write和innerHTML的区别
		执行结果显示：document.write会将页面上的所有内容清除包括标题。
		执行结果显示：innerHTML只会重写所属元素的内容，即<div>元素中的内容。

浏览器/html/css面试题
	1.什么是盒模型
		在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），
		元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，
		而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。
	2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？
		行内元素：a、b、span、img、input、strong、select、label、em、button、textarea
		块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote
		空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img
		行内元素不可以设置宽高，不独占一行;
		块级元素可以设置宽高，独占一行。
	3.简述src和href的区别
		src 是指向物件的来源地址，是引入。在 img、script、iframe 等元素上使用。
		href 是超文本引用，指向需要连结的地方，是与该页面有关联的，是引用。在 link和a 等元素上使用。
	4.什么是css Hack
		CSS hack：由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，
		或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，
		得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，
		能在不同的浏览器中也能得到我们想要的页面效果。
	5.什么叫优雅降级和渐进增强
		优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，
		则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,
		为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.
		渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,
		向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
	6.px和em和rem的区别
		(1).PX是Pixel的缩写，也就是说像素是指基本原色素及其灰度的基本编码，
		由 Picture(图像) 和 Element（元素）这两个单词的字母所组成的，如同摄影的相片一样，数码影像也具有连续性的浓淡阶调。
		若把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”。
		(2).em单位名称为相对长度单位。相对于当前对象内文本的字体尺寸，国外使用比较多。
		<em>(emphasize) 标签告诉浏览器把其中的文本表示为强调的内容。对于所有浏览器来说，这意味着要把这段文字用斜体来显示。
		(3).REM是相对单位，是相对HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，
		通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。
		目前，除了IE8及更早版本外，所有浏览器均已支持rem。
	7.一次完整的HTTP事务是怎么一个过程
		域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，
		浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 
		浏览器对页面进行渲染呈现给用户
	8.HTTPS是如何实现加密
		1，服务端生成jks文件，并导出只含公钥的ser文件给服务端
		2，客户端用ser文件生成自己的bks文件，用来验证服务端的消息
		3，客户端自己生成pfx文件，并导出只含公钥的ser文件给服务端
		4，服务端用客户端的ser文件进行验证来自客户端的消息
	9.浏览器是如何渲染页面的？
		处理HTML标记并构建DOM树
		处理CSS标记并构建CSSOM树
		将DOM与CSSOM合并成一个渲染树
		根据渲染树来布局，计算每个节点的布局信息
		将各个节点绘制到屏幕上
	10.浏览器的内核有哪些？分别有什么代表的浏览器
		Trident内核：IE最先开发或使用的，也称IE内核，360浏览器使用的也是IE内核；
		Webkit内核：谷歌chrome浏览器最先开发或使用，也叫谷歌内核，枫树浏览器、太阳花使用的也是谷歌内核；
		Gecko内核： Netscape6开始采用的内核，后来的Mozilla FireFox (火狐浏览器) 也采用了该内核，K-Meleon浏览器也是使用这种内核；
		Presto内核：目前只有Opera浏览器采用该内核
	11.页面载入时，link和@import有什么区别？
	   （1）link属于xhtml标签，除了加载css之外，还能用于定义RSS,定义rel连接属性等作用而@import是css提供的只用于加载css
	   （2）页面加载时，link会同时被加载；@import引用css会等页面加载完毕之后在加载
	   （3）@import只有ie5以上浏览器才兼容，而link属于xhtml无兼容问题
	12.如何优化图像，图像格式的区别
		