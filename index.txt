//vue面试题
一.vue面试题;

框架
    1.mvvm 框架是什么
    Mvvm定义MVVM是Model-View-ViewModel的简写 即模型-视图-视图模型 模型 指的是后端传递的数据 视图 指的是所看到的
	页面  视图模型 mvvm模式的核心,它是连接view和model的桥梁 它有两个方向:
    一是将 模型  转化成 视图 即将后端传递的数据转化成所看到的页面 实现的方式是:数据绑定
    二是将 视图 转化成 模型, 即将所看到的页面转化成后端的数据 实现的方式是:DOM 事件监听 这两个方向都实现的,我们称之为数
	据的双向绑定
    总结:在MVVM的框架下视图和模型是不能直接通信的 它们通过ViewModel来通信,ViewModel通常要实现一个observer观察者,当数据发
	生变化,ViewModel能够监听到数据的这种变化,然后通知到对应的视图做自动更新,而当用户操作视图,ViewModel也能监听到视图的变化
	然后通知数据做改动,这实际上就实现了数据的双向绑定
    2.mvc 框架是什么
    MVC的定义:MVC是Model-View- Controller的简写 即模型-视图-控制器 M和V指的意思和MVVM中的M和V意思一样 C即Controller指的是
	页面业务逻辑 使用MVC的目的就是将M和V的代码分离  MVC是单向通信 也就是View跟Model,必须通过Controller来承上启下MVC
    MVVM的区别并不是VM完全取代了C ,ViewModel存在目的在于抽离Controller中展示的业务逻辑,而不是替代Controller,其它视图操作业
	务等还是应该放在Controller中实现 也就是说MVVM实现的是业务逻辑组件的重用

生命周期函数面试题
    1.什么是vue生命周期
        Vue实例有一个完整的生命周期,也就是从开始创建 初始化数据 编译模板 挂载DOM 渲染 一 更新 卸载等一系列过程
        (通俗话讲 就是Vue实例从创建到销毁的过程)
    2.vue生命周期的作用是什么
        它的生命周期中有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑
    3.vue生命周期总共有几个阶段
        它可以总共分为8个阶段 创建前/后, 载入前/后,更新前/后,销毁前/销毁后
    4.第一次页面加载会触发哪几个钩子
        第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
    5.简述每个周期具体适合哪些场景
        生命周期钩子的一些使用方法 : beforecreate : 可以在这加个loading事件,在加载实例时触发 created : 初始化完成时的事件写在
		这里,如在这结束loading事件,异步请求也适宜在这里调用 mounted : 挂载元素,获取到DOM节点 updated : 如果对数据统一处理,在
		这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom
    6.created和mounted的区别
        created:在模板渲染成html前调用,即通常初始化某些属性值,然后再渲染成视图
        mounted:在模板渲染成html后调用,通常是初始化页面完成后,再对html的dom节点进行一些需要的操作
    7.vue获取数据在哪个周期函数
        created

vue路由面试题
    1.vue-router 是什么? 它有哪些组件
        vue-router是Vue.js官方的路由插件,它和vue.js是深度集成的,适合用于构建单页面应用 vue的单页面应用是基于路由和组件的,路由
		用于设定访问路径,并将路径和组件映射起来 传统的页面应用 是用一些超链接来实现页面切换和跳转的 在vue-router单页面应用中
		,则是路径之间的切换,也就是组件的切换
    2. active-class 是哪个组件的属性?
        router-link
        设置 链接激活时使用的 CSS 类名 默认值可以通过路由的构造选项 linkActiveClass 来全局配置
    4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值
         创建组件 引入组件
         定义路由 path配置组件路径(动态路由加: /"内容" )
         实现路由跳转 router-link (加参数)
         this.$route.params
    5.vue-router 有哪几种导航钩子?
         全局导航钩子
            beforeEach
            beforeResolve
            afterEach
         某个路由独享的导航钩子
            beforeEnter
         路由组件上的导航钩子
            beforeRouteEnter
            beforeRouteUpdate (2.2 新增)
            beforeRouteLeave
    6.$route 和 $router 的区别
         this.$route相当于当前激活的路由对象 包含当前url解析得到的数据 可以从对象里获取一些数据,如name,path等
         this.$router是VueRouter的实例方法,当导航到不同url,可以使用this.$router.push方法,这个方法则会向history里面添加一条记
		 录,当点击浏览器回退按钮或者this.$router.back()就会回退之前的url
    7.vue-router响应路由参数的变化
         watch (监测变化) $route
         beforeRouteUpdate
    8.vue-router传参
         get方法 <router-link :to="{path:'/test',query: {name: id}}">跳转</router-link>
            接收值 this.$route.query.name
         post方法 <router-link :to="{path:'/test',push: {name: id}}">跳转</router-link>
            接收值 this.$route.query.name
         路由方法
             props:{name:{required:false,default:''}}
    9.vue-router的两种模式
         vue-router 默认 hash 模式,还有一种是history模式
         hash模式的工作原理是hashchange事件,可以在window监听hash的变化.我们在url后面随便添加一个#xx触发这个事件
         history模式把window.history对象打印出来可以看到里边提供的方法和记录长度
    10.vue-router实现路由懒加载(动态加载路由 )
        vue异步组件 component: resolve => require(['@/components/home'],resolve)
        es提案的import() const About = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/about')
        webpack的require,ensure() component: r => require.ensure([], () => r(require('@/components/home')), 'demo')

vue常见面试题
    1.vue是什么
        Vue是一个渐进式的javascript开发框架,通过组件的开发,最后进行组件的组合,合并组件形成页面
        自动化构建工具
        构造器(构造函数)
    2.vue优点
        组件化开发
        单页面路由
        丰富的Api方法
        双向的数据绑定
        单向数据流
        易于结合其他第三库
    3.vue父组件向子组件传递数据?
        父组件的data中定义值,引入并调用子组件,在引用的子组件的标签上通过v-bind指令给子组件传值,子组件通过在data中定义的
		props属性接收父组件传过来的值然后应用到子组件里
            子组件接受的父组件的值分为  引用类型和普通类型两种
            普通类型:字符串(String) 数字(Number) 布尔值(Boolean) 空(Null)
            引用类型:数组(Array) 对象(Object)
            其中,普通类型是可以在子组件中更改,不会影响其他兄弟子组件内同样调用的来自父组件的值
            但是,引用类型的值,当在子组件中修改后,父组件的也会修改
    4.子组件像父组件传递事件?
        this.$emit('message', '第一个参数', '第二个参数');
            message在父组件  <div @message="getMyEvent"></div>
    5.v-show和v-if指令的共同点和不同点
        v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点
        v-show只是在修改元素的css样式,也就是display的属性值,元素始终在Dom树上
    6.如何让CSS只在当前组件中起作用
        <style scoped></style>
    7.<keep-alive></keep-alive>的作用是什么?
        <keep-alive>是Vue的内置组件,能在组件切换过程中将状态保留在内存中,防止重复渲染DOM
        <keep-alive> 包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 和 <transition> 相似,<keep-alive>是一个抽象组
		件:它自身不会渲染一个 DOM 元素,也不会出现在父组件链中
    8.如何获取dom
        Vue提供的ref属性以及this.$refs即可实现
        <div ref='box'  v-on:click="changeText()">这是一个盒子</div>
        changeText: function() {
            this.$refs.box.innerHTML = "改变盒子的文字";
        }
    9.说出几种vue当中的指令和它的用法?
        v-if 判断是否隐藏
        v-show 控制的隐藏出现,只是将css属性设为了display:none 或block;
        v-for 进行列表和表格的渲染
        v-bind 绑定属性
        v-model 双向数据绑定
        v-html 获取html标签
        v-text不解释标签
    10.vue-loader是什么?使用它的用途有哪些?
        vue-loader是解析 .vue 文件的一个加载器,跟 template/js/style转换成 js 模块;
        用途:js可以写es6 style样式可以scss或less template可以加jade等
    11.为什么使用key
        vue中列表循环需加:key="唯一标识" 唯一标识可以是item里面id index等 ,		            			              因为vue组件高度复用增加Key可以标识组件的唯一性
		,为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM
    12.axios及安装
        npm install axios --save
    13.为什么要有跨域限制
        跨域:指的是浏览器不能执行其他网站的脚本 它是由浏览器的同源策略造成的,是浏览器对javascript施加的安全限制
        同源策略(Same origin policy)是一种约定,它是浏览器最核心也最基本的安全功能.如果缺少了同源策略,则浏览器的正常功能
		可能都会受到影响 可以说 Web 是构建在同源策略基础之上的,浏览器只是针对同源策略的一种实现
        因为存在浏览器同源策略,所以才会有跨域问题
    14.axios解决跨域
        首先在main.js中,配置下我们访问的Url前缀:Axios.defaults.baseURL = '/api';
        配置代理 : 修改config文件夹下的index.js文件，在proxyTable中加上如下代码:
            '/api':{
                target: "https://www.v2ex.com/api",
                    changeOrigin:true,
                    pathRewrite:{
                    '^/api':''
                }
            }
        修改请求Url:修改刚刚的axios请求，把url修改如下
        因为我们给url加上了前缀 /api，我们访问 http://127.0.0.1:19323/site/info.json 
		就当于访问了：http://127.0.0.1:19323/api/site/info.json。(假设本地访问端口号为 19323)
        又因为在 index.js 中的 proxyTable 中拦截了 /api ,并把 /api 及其前面的所有替换成了 target 中的内容，
		因此实际访问 Url 是https://www.v2ex.com/api/site/info.json。
	15.v-modal的使用
		(1).v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。
			你应该通过 JavaScript 在组件的 data 选项中声明初始值。
		(2).对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)
		(3).在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。
			你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步
		(4).如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符
	16.scss的安装以及使用
		less与scss部分功能是相同的，都可以简化样式的编写，但是在开发中发现，当希望通过函数处理某些数据的时候，
		无法定义数据的返回,而scss可以完成对数据运算后返回数据方法的定义，因此决定使用scss
		npm install -g sass
	17.请说出vue.cli项目中src目录每个文件夹和文件的用法？
		assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置；
		view视图；app.vue是一个应用主组件；main.js是入口文件.
	18.分别简述computed和watch的使用场景
		(1).watch和computed都是以Vue的依赖追踪机制为基础，它们都试图处理这样一件事情：当某一个数据（称它为依赖数据）
		发生变化的时候，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据的变动。
			methods用来定义函数，它需要手动调用才能执行，需要像”fuc()”这样去调用它（假设函数为fuc）.
			computed是计算属性，事实上和data对象里的数据属性是同一类的（使用上），在取值的时候，
			用this.fullName去取用，就和取data一样（不要当成函数调用！！）
		watch擅长处理的场景：一个数据影响多个数据 
		computed擅长处理的场景：一个数据受多个数据影响 
	19.v-on可以监听多个方法吗
		(1).<button @click="a(),b()">点我ab</button>
		(2).<button v-on="{mouseenter: onEnter,mouseleave: onLeave}">鼠标进来</button>
			<button @mouseenter="onEnter" @mouseleave="onLeave">鼠标进来</button>
		(3). v-on修饰符  .stop .prevent .capture .self 以及指定按键.{keyCode|keyAlias} 
			这里的.stop 和 .prevent也可以通过传入&event进行操作 
			全部按键别名有：enter tab delete esc space up down left right 
			<form @keyup.delete="onKeyup" @submit.prevent="onSubmit">
				<input type="text" placeholder="在这里按delete">
				<button type="submit">点我提交</button>
			</form>
	20.$nextTick的使用
		(1).为什么要使用$nextTick：这是由于Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，
		然后把在同一个事件循环 (event loop) 当中观察到数据变化的watcher推送进这个队列。如果这个watcher被触发多次，
		只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和dom操作。而在下一个事件循环开始时，
		Vue会进行必要的dom更新，并清空队列（$nextTick方法就相当于在dom更新和清空队列后额外插入的执行步骤）
		(2).$nextTick是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
	21.vue组件中data为什么必须是一个函数
		如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，
		让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，
		就会造成一个变了全都会变的结果。
	22.vue事件对象的使用
		v-on:click 简写@click 阻止冒泡@click.stop
	23.组件间的通信
		父组件向子组件传递数据通过设置标签的属性传递数据，在子组件用props接受
		子组件向父组件传递数据 this.$emit("titleChanged","子向父组件传值");
	24.渐进式框架的理解
		在我看来，渐进式代表的含义是：主张最少。
		每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。
		比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：
		- 必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）

		所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。

		比如React，它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。

		Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。
		渐进式的含义，我的理解是：没有多做职责之外的事。
	25.Vue中双向数据绑定是如何实现的
		VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设
		置属性值(set)的操作来实现的。
	26.单页面应用和多页面应用区别及优缺点
		单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。
		所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，
		单页面的页面跳转，仅刷新局部资源。多应用于pc端。
			单页面的优点：
			1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小
			2，前后端分离
			3，页面效果会比较炫酷（比如切换页面内容时的专场动画）
		多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新
			单页面缺点：
			1，不利于seo
			2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，
			所以需要自己建立堆栈管理）
			3，初次加载时耗时多
			4，页面复杂度提高很多
	27.vue中过滤器有什么作用及详解
		过滤器分为全局过滤器和本地过滤器,全局过滤器顾名思义就是所有Vue实例挂载的元素内都能使用，
		而本地过滤器则是指只有过滤器函数所在的Vue实例挂载的元素内可以使用
			全局过滤器：
			Vue.filter('Upper',function (name) {
					return name.toUpperCase();
			});
			本地过滤器：
			  var vm=new Vue({
					el: '#app',
					data: {
						name:'martin'
					},
					filters:{
						Upper:function (name) {
							return name.toUpperCase()
						}
					}
				})
	28.v-if和v-for的优先级
		永远不要把 v-if 和 v-for 同时用在同一个元素上。
		当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级
	29.assets和static的区别
		相同点：
			assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，
			这是相同点 
		不相同点：
		(1).assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，
		所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html
		一同上传至服务器
		(2).static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。
		因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static中的资源文件由于没有进行压缩等操作，
		所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大的空间。所以简单点使用建议如下：
		(3).将项目中template需要的样式文件js文件等都可以放置在assets中，走打包这一流程。减少体积。
		而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，
		我们不再需要处理，直接上传。
	30.列举常用的指令
		插入文本:v-text
		插入HMTL:v-html
		循环:v-for
		绑定事件:v-on
		双向绑定:v-model
		属性绑定:v-bind
		条件渲染:v-show 是否隐藏元素
		条件渲染:if ... else if ...else型
	31.vue常用的修饰符
		1.事件修饰符
			.stop 阻止冒泡
			.prevent 防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）
			.capture 与事件冒泡的方向相反，事件捕获由外到内,捕获事件：嵌套两三层父子关系，然后所有都有点击事件，点击子节点，
				就会触发从外至内 父节点-》子节点的点击事件
			.self 只会触发自己范围内的事件，不包含子元素
			.once 只执行一次
		2.键盘修饰符
			.enter：回车键
			.tab：制表键
			.delete：含delete和backspace键
			.esc：返回键
			.space: 空格键
			.up：向上键
			.down：向下键
			.left：向左键
			.right：向右键
		3.自定义按键修饰符别名
			在Vue中可以通过config.keyCodes自定义按键修饰符别名。
			 <input type="text" @keyup.f5="prompt()" />按下F5，会触发prompt方法
		4.修饰符
			.lazy在改变后才触发（也就是说只有光标离开input输入框的时候值才会改变）
			.number将输出字符串转为Number类型・（虽然type类型定义了是number类型，但是如果输入字符串，输出的是string）
			.trim自动过滤用户输入的首尾空格
	32.数组更新检测 (由于 Javascript 的限制，Vue 不能检测到以下变动的数组：)
		Vue包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：
			push()
			pop()
			shift()
			unshift()
			splice()
			sort()
			reserve()
		替换数组
			例如： filter(), concat() 和 slice() 。这些方法不会改变原始数组，但总是会返回一个新数组。
	33.Vue.set视图更新
		this.$set()和Vue.set()本质方法一样，前者可以用在methods中使用。set方法调用时，可以触发页面全部重新渲染。
	34.自定义指令详解
		Vue.directive自定义指令
		自定义指令中传递的三个参数
			el: 指令所绑定的元素，可以用来直接操作DOM。
			binding:  一个对象，包含指令的很多信息。
			vnode: Vue编译生成的虚拟节点。
		自定义指令的生命周期
			bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。
			inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。
			update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，
				可以忽略不必要的模板更新。
			componentUpdated:被绑定元素所在模板完成一次更新周期时调用。
			unbind:只调用一次，指令与元素解绑时调用。
	35.vue的两个核心点
		Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动、组件系统。
			数据驱动：
				Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter
				（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。
			组件系统：
				应用类UI可以看作全部是由组件树构成的。
	36.vue和jQuery的区别
		(1).jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，
		其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。
		比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。 
		(2).Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象
		，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。
	37.引进组件的步骤
		1.在template中引入组件
		2.在script的第一行用import引入路径
		3.用component中写上组件名称
	38.Vue-cli打包命令是什么？打包后悔导致路径问题，应该在哪里修改
		命令行输入：npm  run  build
			到config文件夹中打开index.js文件
			assetsPublicPath属性作用是指定编译发布的根目录，‘/’指的是项目的根目录 ，’./’指的是当前目录。
	39.	三大框架的对比
						Angular		React		Vue
			组织方式	MVC			模块化		模块化
			数据绑定	双向绑定	单向绑定	双向绑定
			模板能力	强大		自由		自由
			自由度		较小		大			较大
			路由		静态路由	动态路由	动态路由
	40.跨组件双向数据绑定
		父子组件之间的数据传递
		对象的引用关系() 该方法运用的是对象的引用关系，来实现的。
		 .sync   this.$emit('update:name',this.newName);
		v-model (模仿v-model)
			newValue: {
				get:function() {
				return this.value; 
				},
				set:function(value) {
				this.$emit('input', value);
				}
			}
	41.delete和Vue.delete删除数组的区别
		delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
		Vue.delete 直接删除了数组 改变了数组的键值。
	42.Vue-router跳转和location.href有什么区别
		<router-link> 比起写死的 <a href="..."> 会好一些，
		理由如下：无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，
		或者在 IE9 降级使用 hash 模式，无须作任何变动。在 HTML5 history 模式下，router-link 会守卫点击事件，
		让浏览器不再重新加载页面。当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。
	43. vue slot
		是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑
		（替换组件模板中<slot> 位置），当插槽也就是坑<slot name=”mySlot”>有命名时，
		组件标签中使用属性slot=”mySlot”的元素就会替换该对应位置内容；
		
		简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，
		就是slot分发负责的活。
	44.你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？
		根据vue-cli脚手架规范，一个js文件，一个CSS文件。
	45.axios的特点有哪些
		axios是一个基于promise的HTTP库，支持promise的所有API；
		它可以拦截请求和响应；
		它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据；
		它安全性更高，客户端支持防御XSRF；
	46.请说下封装 vue 组件的过程？
		首先，使用Vue.extend()创建一个组件
		然后，使用Vue.component()方法注册组件
		接着，如果子组件需要数据，可以在props中接受定义
 		最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
	47.vue 各种组件通信方法（父子 子父 兄弟 爷孙 毫无关系的组件）
		父子:组件的props属性用于接收父组件传递的信息. 
		子父:而子组件想要向父组件传递信息, 可以使用$emit事件
		爷孙:它们可以分解为两个父子组件通信
		兄弟:兄弟组件通信即组件之间通信. 这就要用到观察者模式了. 因为vue实例的原型全部来自Vue.prototype.
			那么我们就可以了将事件中心绑定到Vue.prototype的某个属性上 
			let bus = new Vue()
			Vue.prototype.bus = bus
			this.bus.$on('send', (msg)=> {
			  this.msg = (msg)
			})
			//函数
			toUp() {
			  this.bus.$emit('send', 'down来消息了')
			}
	48.params和query的区别
		query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
		注意接收参数的时候，已经是$route而不是$router了哦！！
		query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
	49.vue初始化页面闪动问题
		v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。
		v-text vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
	50.vue更新数组时触发视图更新的方法
		push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
		pop() 方法用于删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。
		shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。
		unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
		splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组。
		sort() 方法用于对数组的元素进行排序。
		reverse() 方法用于颠倒数组中元素的顺序。
		Vue.set() 响应式新增与修改数据
	51.vue常用的UI组件库
		 iView UI组件库 (https://www.iviewui.com/)
		 Vux UI组件库 (https://vux.li/)
		 Element UI组件库 (http://element.eleme.io/#/zh-CN)
		 Mint UI组件库 (http://mint-ui.github.io/#!/zh-cn)
		 Bootstrap-Vue UI组件库 (https://bootstrap-vue.js.org/)
		 Ant Design Vue UI组件库 (https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/)
		 AT-UI UI组件库 (https://at-ui.github.io/at-ui/#/zh)
		 Vant UI组件库 (https://youzan.github.io/vant/#/zh-CN/intro)
		 cube-ui UI组件库 (https://didi.github.io/cube-ui/#/zh-CN)
		 Muse-UI UI组件库 (https://muse-ui.org/#/zh-CN)
		 N3-components UI组件库 (https://n3-components.github.io/N3-components/component.html)
		 Mand Mobile(https://didi.github.io/mand-mobile/#/zh-CN/home)
	52.vue如何引进本地背景图片
		vue在data引入本地图片(在img元素中用：src绑定地址的)
		直接在CSS样式中引用的
	53. vue如何引进sass
		安装sass的依赖包 (npm install --save-dev sass-loader)
		进入build文件，在webpack.base.config.js中module.rules配置
		修改components目录中的Hello.vue文件的style标签 (<style lang='scss'><style>)
	54.vue修改打包后静态资源路径的修改
		我们只需要修改编译后的环境，所以只要修改prod.env.js下的build属性下的assetsPublicPath属性
		默认值是 "/" 根目录
		我这里加了一级 "/mywebsite/"
		最终页面上请求到的静态资源路径，比如css文件的地址就是：
		http://www.***.cn/mywebsite/static/css/index****.css

vuex常见面试题
	1.vuex是什么？怎么使用？哪种功能场景使用它？
		vue框架中状态管理。
		在main.js引入store，注入。
		场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
	2.vuex有哪几种属性
		state => 基本数据 
		getters => 从基本数据派生的数据 
		mutations => 提交更改数据的方法，同步！ 
		actions => 像一个装饰器，包裹mutations，使之可以异步。 
		modules => 模块化Vuex
	3.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
		如果您使用vuex的话，建议您存入vuex中，因为actions可以执行异步操作。同上，简单的页面放在methods里面即可。
		比较复杂，或者重要建议放在vuex中，容易维护，代码清晰,并且调用简单，这个在项目后期很重要。
	4.Vuex中如何异步修改状态
		在调用vuex中的方法action的时候，用promise实现异步修改
	5.Vuex中actions和mutations的区别
		action主要处理的是异步的操作，mutation必须同步执行，而action就不受这样的限制，也就是说action中我们既可以处理同步，
		也可以处理异步的操作
		action改变状态，最后是通过提交mutation

二.ES6面试题
	
ES6新增方法面试题
	1.let const var比较
		var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
		let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
		const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。
		(全局作用域 函数作用域 块级作用域)
	2.反引号（`）标识
		普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
	3.函数默认参数
		 var f = function (a = 10,b = 10,c = 2a+b) {
            console.log(a+b)
            console.log(c)
         };
		f();
	4.箭头函数
		箭头函数this为父作用域的this，不是调用时的this
		箭头函数不能作为构造函数，不能使用new
		箭头函数返回对象时，要加一个小括号
		箭头函数没有arguments，caller，callee
		箭头函数通过call和apply调用，不会改变this指向，只会传入参数
		箭头函数没有原型属性
	5.属性简写
		同名的属性可以省略不写用"," 代替
	6.Object.keys()方法，获取对象的所有属性名或方法名
		用Object.keys()方法获取属性对应的值
		该方法可获得对象的属性名，返回一个数组
	7.import和export
		import语句用于导入由另一个模块导出的绑定。	
		用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，一边其他程序可以通过import语句使用它们。
	8.Promise对象
		promise是异步编程的一种解决方法。
		是一个构造函数，这个构造函数里有两个参数，分别是：resolve（成功之后的回调函数）、reject（失败之后的回调函数）。
		Pending：进行中
		Resolved(Fulfilled)：已完成
		Rejected：已失败
		所谓promise，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，
		从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，
		各种异步操作都可以用同样的方法进行处理。
	9.解构赋值
		let [a, b, c] = [1, 2, 3] // a=1, b=2, c=3
		let {a, b} = {a: 'aaaa', b: 'bbbb'} // a='aaaa' b='bbbb'
	10.set数据结构（可用于快速去重）
		类似于数组，但是成员的值都是唯一的，没有重复。Set本身是一个构造函数，用来生成Set数据结构
		const s = new Set();
		[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
	11.Spread Operator 展开运算符(...)
		(1).组装对象或者数组
			//数组
			const color = [ 'red' , 'yellow' ]
			const colorful = [...color, 'green' , 'pink' ]
			console.log(colorful)

			//对象
			const alp = { first:'a',second:'b' }
			const alphabets = { ...alp,third: 'c'}
			
ES6数组面试题
	1.forEach()
		forEach():遍历数组,并为每个元素调用传入的函数; 举例:
	2.map()
		方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
	3.filter()
		判断数组中是否存在某个值 方法返回一个新数组，
	4.reduce()
		reduce() 方法接收一个函数作为累加器,reduce 为数组中的每一个元素依次执行回调函数，
		不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组 
	5.some()
		方法用于检测数组中的元素是否满足指定条件（函数提供）。
		some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。
	6.every()
		方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。
		every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。
	7.all()方法
		Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

js面试题
	