//vue面试题
一.vue面试题;

框架
    1.mvvm 框架是什么
    Mvvm定义MVVM是Model-View-ViewModel的简写 即模型-视图-视图模型 模型 指的是后端传递的数据 视图 指的是所看到的
	页面  视图模型 mvvm模式的核心,它是连接view和model的桥梁 它有两个方向:
    一是将 模型  转化成 视图 即将后端传递的数据转化成所看到的页面 实现的方式是:数据绑定
    二是将 视图 转化成 模型, 即将所看到的页面转化成后端的数据 实现的方式是:DOM 事件监听 这两个方向都实现的,我们称之为数
	据的双向绑定
    总结:在MVVM的框架下视图和模型是不能直接通信的 它们通过ViewModel来通信,ViewModel通常要实现一个observer观察者,当数据发
	生变化,ViewModel能够监听到数据的这种变化,然后通知到对应的视图做自动更新,而当用户操作视图,ViewModel也能监听到视图的变化
	然后通知数据做改动,这实际上就实现了数据的双向绑定
    2.mvc 框架是什么
    MVC的定义:MVC是Model-View- Controller的简写 即模型-视图-控制器 M和V指的意思和MVVM中的M和V意思一样 C即Controller指的是
	页面业务逻辑 使用MVC的目的就是将M和V的代码分离  MVC是单向通信 也就是View跟Model,必须通过Controller来承上启下MVC
    MVVM的区别并不是VM完全取代了C ,ViewModel存在目的在于抽离Controller中展示的业务逻辑,而不是替代Controller,其它视图操作业
	务等还是应该放在Controller中实现 也就是说MVVM实现的是业务逻辑组件的重用

生命周期函数面试题
    1.什么是vue生命周期
        Vue实例有一个完整的生命周期,也就是从开始创建 初始化数据 编译模板 挂载DOM 渲染 一 更新 卸载等一系列过程
        (通俗话讲 就是Vue实例从创建到销毁的过程)
    2.vue生命周期的作用是什么
        它的生命周期中有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑
    3.vue生命周期总共有几个阶段
        它可以总共分为8个阶段 创建前/后, 载入前/后,更新前/后,销毁前/销毁后
    4.第一次页面加载会触发哪几个钩子
        第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
    5.简述每个周期具体适合哪些场景
        生命周期钩子的一些使用方法 : beforecreate : 可以在这加个loading事件,在加载实例时触发 created : 初始化完成时的事件写在
		这里,如在这结束loading事件,异步请求也适宜在这里调用 mounted : 挂载元素,获取到DOM节点 updated : 如果对数据统一处理,在
		这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom
    6.created和mounted的区别
        created:在模板渲染成html前调用,即通常初始化某些属性值,然后再渲染成视图
        mounted:在模板渲染成html后调用,通常是初始化页面完成后,再对html的dom节点进行一些需要的操作
    7.vue获取数据在哪个周期函数
        created

vue路由面试题
    1.vue-router 是什么? 它有哪些组件
        vue-router是Vue.js官方的路由插件,它和vue.js是深度集成的,适合用于构建单页面应用 vue的单页面应用是基于路由和组件的,路由
		用于设定访问路径,并将路径和组件映射起来 传统的页面应用 是用一些超链接来实现页面切换和跳转的 在vue-router单页面应用中
		,则是路径之间的切换,也就是组件的切换
    2. active-class 是哪个组件的属性?
        router-link
        设置 链接激活时使用的 CSS 类名 默认值可以通过路由的构造选项 linkActiveClass 来全局配置
    4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值
         创建组件 引入组件
         定义路由 path配置组件路径(动态路由加: /"内容" )
         实现路由跳转 router-link (加参数)
         this.$route.params
    5.vue-router 有哪几种导航钩子?
         全局导航钩子
            beforeEach
            beforeResolve
            afterEach
         某个路由独享的导航钩子
            beforeEnter
         路由组件上的导航钩子
            beforeRouteEnter
            beforeRouteUpdate (2.2 新增)
            beforeRouteLeave
    6.$route 和 $router 的区别
         this.$route相当于当前激活的路由对象 包含当前url解析得到的数据 可以从对象里获取一些数据,如name,path等
         this.$router是VueRouter的实例方法,当导航到不同url,可以使用this.$router.push方法,这个方法则会向history里面添加一条记
		 录,当点击浏览器回退按钮或者this.$router.back()就会回退之前的url
    7.vue-router响应路由参数的变化
         watch (监测变化) $route
         beforeRouteUpdate
    8.vue-router传参
         get方法 <router-link :to="{path:'/test',query: {name: id}}">跳转</router-link>
            接收值 this.$route.query.name
         post方法 <router-link :to="{path:'/test',push: {name: id}}">跳转</router-link>
            接收值 this.$route.query.name
         路由方法
             props:{name:{required:false,default:''}}
    9.vue-router的两种模式
         vue-router 默认 hash 模式,还有一种是history模式
         hash模式的工作原理是hashchange事件,可以在window监听hash的变化.我们在url后面随便添加一个#xx触发这个事件
         history模式把window.history对象打印出来可以看到里边提供的方法和记录长度
    10.vue-router实现路由懒加载(动态加载路由 )
        vue异步组件 component: resolve => require(['@/components/home'],resolve)
        es提案的import() const About = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/about')
        webpack的require,ensure() component: r => require.ensure([], () => r(require('@/components/home')), 'demo')

vue常见面试题
    1.vue是什么
        Vue是一个渐进式的javascript开发框架,通过组件的开发,最后进行组件的组合,合并组件形成页面
        自动化构建工具
        构造器(构造函数)
    2.vue优点
        组件化开发
        单页面路由
        丰富的Api方法
        双向的数据绑定
        单向数据流
        易于结合其他第三库
    3.vue父组件向子组件传递数据?
        父组件的data中定义值,引入并调用子组件,在引用的子组件的标签上通过v-bind指令给子组件传值,子组件通过在data中定义的
		props属性接收父组件传过来的值然后应用到子组件里
            子组件接受的父组件的值分为  引用类型和普通类型两种
            普通类型:字符串(String) 数字(Number) 布尔值(Boolean) 空(Null)
            引用类型:数组(Array) 对象(Object)
            其中,普通类型是可以在子组件中更改,不会影响其他兄弟子组件内同样调用的来自父组件的值
            但是,引用类型的值,当在子组件中修改后,父组件的也会修改
    4.子组件像父组件传递事件?
        this.$emit('message', '第一个参数', '第二个参数');
            message在父组件  <div @message="getMyEvent"></div>
    5.v-show和v-if指令的共同点和不同点
        v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点
        v-show只是在修改元素的css样式,也就是display的属性值,元素始终在Dom树上
    6.如何让CSS只在当前组件中起作用
        <style scoped></style>
    7.<keep-alive></keep-alive>的作用是什么?
        <keep-alive>是Vue的内置组件,能在组件切换过程中将状态保留在内存中,防止重复渲染DOM
        <keep-alive> 包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 和 <transition> 相似,<keep-alive>是一个抽象组
		件:它自身不会渲染一个 DOM 元素,也不会出现在父组件链中
    8.如何获取dom
        Vue提供的ref属性以及this.$refs即可实现
        <div ref='box'  v-on:click="changeText()">这是一个盒子</div>
        changeText: function() {
            this.$refs.box.innerHTML = "改变盒子的文字";
        }
    9.说出几种vue当中的指令和它的用法?
        v-if 判断是否隐藏
        v-show 控制的隐藏出现,只是将css属性设为了display:none 或block;
        v-for 进行列表和表格的渲染
        v-bind 绑定属性
        v-model 双向数据绑定
        v-html 获取html标签
        v-text不解释标签
    10.vue-loader是什么?使用它的用途有哪些?
        vue-loader是解析 .vue 文件的一个加载器,跟 template/js/style转换成 js 模块;
        用途:js可以写es6 style样式可以scss或less template可以加jade等
    11.为什么使用key
        vue中列表循环需加:key="唯一标识" 唯一标识可以是item里面id index等 ,		            			              因为vue组件高度复用增加Key可以标识组件的唯一性
		,为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM
    12.axios及安装
        npm install axios --save
    13.为什么要有跨域限制
        跨域:指的是浏览器不能执行其他网站的脚本 它是由浏览器的同源策略造成的,是浏览器对javascript施加的安全限制
        同源策略(Same origin policy)是一种约定,它是浏览器最核心也最基本的安全功能.如果缺少了同源策略,则浏览器的正常功能
		可能都会受到影响 可以说 Web 是构建在同源策略基础之上的,浏览器只是针对同源策略的一种实现
        因为存在浏览器同源策略,所以才会有跨域问题
    14.axios解决跨域
        首先在main.js中,配置下我们访问的Url前缀:Axios.defaults.baseURL = '/api';
        配置代理 : 修改config文件夹下的index.js文件，在proxyTable中加上如下代码:
            '/api':{
                target: "https://www.v2ex.com/api",
                    changeOrigin:true,
                    pathRewrite:{
                    '^/api':''
                }
            }
        修改请求Url:修改刚刚的axios请求，把url修改如下
        因为我们给url加上了前缀 /api，我们访问 http://127.0.0.1:19323/site/info.json 
		就当于访问了：http://127.0.0.1:19323/api/site/info.json。(假设本地访问端口号为 19323)
        又因为在 index.js 中的 proxyTable 中拦截了 /api ,并把 /api 及其前面的所有替换成了 target 中的内容，
		因此实际访问 Url 是https://www.v2ex.com/api/site/info.json。
	15.v-modal的使用
		(1).v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。
			你应该通过 JavaScript 在组件的 data 选项中声明初始值。
		(2).对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)
		(3).在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。
			你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步
		(4).如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符
	16.scss的安装以及使用
		less与scss部分功能是相同的，都可以简化样式的编写，但是在开发中发现，当希望通过函数处理某些数据的时候，
		无法定义数据的返回,而scss可以完成对数据运算后返回数据方法的定义，因此决定使用scss
		npm install -g sass
	17.请说出vue.cli项目中src目录每个文件夹和文件的用法？
		assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置；
		view视图；app.vue是一个应用主组件；main.js是入口文件.
	18.分别简述computed和watch的使用场景
		(1).watch和computed都是以Vue的依赖追踪机制为基础，它们都试图处理这样一件事情：当某一个数据（称它为依赖数据）
		发生变化的时候，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据的变动。
			methods用来定义函数，它需要手动调用才能执行，需要像”fuc()”这样去调用它（假设函数为fuc）.
			computed是计算属性，事实上和data对象里的数据属性是同一类的（使用上），在取值的时候，
			用this.fullName去取用，就和取data一样（不要当成函数调用！！）
		watch擅长处理的场景：一个数据影响多个数据 
		computed擅长处理的场景：一个数据受多个数据影响 
	19.v-on可以监听多个方法吗
		(1).<button @click="a(),b()">点我ab</button>
		(2).<button v-on="{mouseenter: onEnter,mouseleave: onLeave}">鼠标进来</button>
			<button @mouseenter="onEnter" @mouseleave="onLeave">鼠标进来</button>
		(3). v-on修饰符  .stop .prevent .capture .self 以及指定按键.{keyCode|keyAlias} 
			这里的.stop 和 .prevent也可以通过传入&event进行操作 
			全部按键别名有：enter tab delete esc space up down left right 
			<form @keyup.delete="onKeyup" @submit.prevent="onSubmit">
				<input type="text" placeholder="在这里按delete">
				<button type="submit">点我提交</button>
			</form>
	20.$nextTick的使用
		(1).为什么要使用$nextTick：这是由于Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，
		然后把在同一个事件循环 (event loop) 当中观察到数据变化的watcher推送进这个队列。如果这个watcher被触发多次，
		只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和dom操作。而在下一个事件循环开始时，
		Vue会进行必要的dom更新，并清空队列（$nextTick方法就相当于在dom更新和清空队列后额外插入的执行步骤）
		(2).$nextTick是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
	21.vue组件中data为什么必须是一个函数
		如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，
		让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，
		就会造成一个变了全都会变的结果。
	22.vue事件对象的使用
		v-on:click 简写@click 阻止冒泡@click.stop
	23.组件间的通信
		父组件向子组件传递数据通过设置标签的属性传递数据，在子组件用props接受
		子组件向父组件传递数据 this.$emit("titleChanged","子向父组件传值");
	24.渐进式框架的理解
		在我看来，渐进式代表的含义是：主张最少。
		每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。
		比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：
		- 必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）

		所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。

		比如React，它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。

		Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。
		渐进式的含义，我的理解是：没有多做职责之外的事。
	25.Vue中双向数据绑定是如何实现的
		VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设
		置属性值(set)的操作来实现的。
	26.单页面应用和多页面应用区别及优缺点
		单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。
		所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，
		单页面的页面跳转，仅刷新局部资源。多应用于pc端。
			单页面的优点：
			1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小
			2，前后端分离
			3，页面效果会比较炫酷（比如切换页面内容时的专场动画）
		多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新
			单页面缺点：
			1，不利于seo
			2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，
			所以需要自己建立堆栈管理）
			3，初次加载时耗时多
			4，页面复杂度提高很多
	27.vue中过滤器有什么作用及详解
		过滤器分为全局过滤器和本地过滤器,全局过滤器顾名思义就是所有Vue实例挂载的元素内都能使用，
		而本地过滤器则是指只有过滤器函数所在的Vue实例挂载的元素内可以使用
			全局过滤器：
			Vue.filter('Upper',function (name) {
					return name.toUpperCase();
			});
			本地过滤器：
			  var vm=new Vue({
					el: '#app',
					data: {
						name:'martin'
					},
					filters:{
						Upper:function (name) {
							return name.toUpperCase()
						}
					}
				})
	28.v-if和v-for的优先级
		永远不要把 v-if 和 v-for 同时用在同一个元素上。
		当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级
	29.assets和static的区别
		相同点：
			assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，
			这是相同点 
		不相同点：
		(1).assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，
		所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html
		一同上传至服务器
		(2).static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。
		因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static中的资源文件由于没有进行压缩等操作，
		所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大的空间。所以简单点使用建议如下：
		(3).将项目中template需要的样式文件js文件等都可以放置在assets中，走打包这一流程。减少体积。
		而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，
		我们不再需要处理，直接上传。
	30.列举常用的指令
		插入文本:v-text
		插入HMTL:v-html
		循环:v-for
		绑定事件:v-on
		双向绑定:v-model
		属性绑定:v-bind
		条件渲染:v-show 是否隐藏元素
		条件渲染:if ... else if ...else型
	31.vue常用的修饰符
		1.事件修饰符
			.stop 阻止冒泡
			.prevent 防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）
			.capture 与事件冒泡的方向相反，事件捕获由外到内,捕获事件：嵌套两三层父子关系，然后所有都有点击事件，点击子节点，
				就会触发从外至内 父节点-》子节点的点击事件
			.self 只会触发自己范围内的事件，不包含子元素
			.once 只执行一次
		2.键盘修饰符
			.enter：回车键
			.tab：制表键
			.delete：含delete和backspace键
			.esc：返回键
			.space: 空格键
			.up：向上键
			.down：向下键
			.left：向左键
			.right：向右键
		3.自定义按键修饰符别名
			在Vue中可以通过config.keyCodes自定义按键修饰符别名。
			 <input type="text" @keyup.f5="prompt()" />按下F5，会触发prompt方法
		4.修饰符
			.lazy在改变后才触发（也就是说只有光标离开input输入框的时候值才会改变）
			.number将输出字符串转为Number类型・（虽然type类型定义了是number类型，但是如果输入字符串，输出的是string）
			.trim自动过滤用户输入的首尾空格
	32.数组更新检测 (由于 Javascript 的限制，Vue 不能检测到以下变动的数组：)
		Vue包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：
			push()
			pop()
			shift()
			unshift()
			splice()
			sort()
			reserve()
		替换数组
			例如： filter(), concat() 和 slice() 。这些方法不会改变原始数组，但总是会返回一个新数组。
	33.Vue.set视图更新
		this.$set()和Vue.set()本质方法一样，前者可以用在methods中使用。set方法调用时，可以触发页面全部重新渲染。
	34.自定义指令详解
		Vue.directive自定义指令
		自定义指令中传递的三个参数
			el: 指令所绑定的元素，可以用来直接操作DOM。
			binding:  一个对象，包含指令的很多信息。
			vnode: Vue编译生成的虚拟节点。
		自定义指令的生命周期
			bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。
			inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。
			update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，
				可以忽略不必要的模板更新。
			componentUpdated:被绑定元素所在模板完成一次更新周期时调用。
			unbind:只调用一次，指令与元素解绑时调用。
	35.vue的两个核心点
		Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动、组件系统。
			数据驱动：
				Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter
				（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。
			组件系统：
				应用类UI可以看作全部是由组件树构成的。
	36.vue和jQuery的区别
		(1).jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，
		其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。
		比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。 
		(2).Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象
		，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。
	37.引进组件的步骤
		1.在template中引入组件
		2.在script的第一行用import引入路径
		3.用component中写上组件名称
	38.Vue-cli打包命令是什么？打包后悔导致路径问题，应该在哪里修改
		命令行输入：npm  run  build
			到config文件夹中打开index.js文件
			assetsPublicPath属性作用是指定编译发布的根目录，‘/’指的是项目的根目录 ，’./’指的是当前目录。
	39.	三大框架的对比
						Angular		React		Vue
			组织方式	MVC			模块化		模块化
			数据绑定	双向绑定	单向绑定	双向绑定
			模板能力	强大		自由		自由
			自由度		较小		大			较大
			路由		静态路由	动态路由	动态路由
	40.跨组件双向数据绑定
		父子组件之间的数据传递
		对象的引用关系() 该方法运用的是对象的引用关系，来实现的。
		 .sync   this.$emit('update:name',this.newName);
		v-model (模仿v-model)
			newValue: {
				get:function() {
				return this.value; 
				},
				set:function(value) {
				this.$emit('input', value);
				}
			}
	41.delete和Vue.delete删除数组的区别
		delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
		Vue.delete 直接删除了数组 改变了数组的键值。
	42.Vue-router跳转和location.href有什么区别
		<router-link> 比起写死的 <a href="..."> 会好一些，
		理由如下：无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，
		或者在 IE9 降级使用 hash 模式，无须作任何变动。在 HTML5 history 模式下，router-link 会守卫点击事件，
		让浏览器不再重新加载页面。当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。
	43. vue slot
		是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑
		（替换组件模板中<slot> 位置），当插槽也就是坑<slot name=”mySlot”>有命名时，
		组件标签中使用属性slot=”mySlot”的元素就会替换该对应位置内容；
		
		简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，
		就是slot分发负责的活。
	44.你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？
		根据vue-cli脚手架规范，一个js文件，一个CSS文件。
	45.axios的特点有哪些
		axios是一个基于promise的HTTP库，支持promise的所有API；
		它可以拦截请求和响应；
		它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据；
		它安全性更高，客户端支持防御XSRF；
	46.请说下封装 vue 组件的过程？
		首先，使用Vue.extend()创建一个组件
		然后，使用Vue.component()方法注册组件
		接着，如果子组件需要数据，可以在props中接受定义
 		最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
	47.vue 各种组件通信方法（父子 子父 兄弟 爷孙 毫无关系的组件）
		父子:组件的props属性用于接收父组件传递的信息. 
		子父:而子组件想要向父组件传递信息, 可以使用$emit事件
		爷孙:它们可以分解为两个父子组件通信
		兄弟:兄弟组件通信即组件之间通信. 这就要用到观察者模式了. 因为vue实例的原型全部来自Vue.prototype.
			那么我们就可以了将事件中心绑定到Vue.prototype的某个属性上 
			let bus = new Vue()
			Vue.prototype.bus = bus
			this.bus.$on('send', (msg)=> {
			  this.msg = (msg)
			})
			//函数
			toUp() {
			  this.bus.$emit('send', 'down来消息了')
			}
	48.params和query的区别
		query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。
		注意接收参数的时候，已经是$route而不是$router了哦！！
		query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
	49.vue初始化页面闪动问题
		v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。
		v-text vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
	50.vue更新数组时触发视图更新的方法
		push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
		pop() 方法用于删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。
		shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。
		unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
		splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组。
		sort() 方法用于对数组的元素进行排序。
		reverse() 方法用于颠倒数组中元素的顺序。
		Vue.set() 响应式新增与修改数据
	51.vue常用的UI组件库
		 iView UI组件库 (https://www.iviewui.com/)
		 Vux UI组件库 (https://vux.li/)
		 Element UI组件库 (http://element.eleme.io/#/zh-CN)
		 Mint UI组件库 (http://mint-ui.github.io/#!/zh-cn)
		 Bootstrap-Vue UI组件库 (https://bootstrap-vue.js.org/)
		 Ant Design Vue UI组件库 (https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/)
		 AT-UI UI组件库 (https://at-ui.github.io/at-ui/#/zh)
		 Vant UI组件库 (https://youzan.github.io/vant/#/zh-CN/intro)
		 cube-ui UI组件库 (https://didi.github.io/cube-ui/#/zh-CN)
		 Muse-UI UI组件库 (https://muse-ui.org/#/zh-CN)
		 N3-components UI组件库 (https://n3-components.github.io/N3-components/component.html)
		 Mand Mobile(https://didi.github.io/mand-mobile/#/zh-CN/home)
	52.vue如何引进本地背景图片
		vue在data引入本地图片(在img元素中用：src绑定地址的)
		直接在CSS样式中引用的
	53. vue如何引进sass
		安装sass的依赖包 (npm install --save-dev sass-loader)
		进入build文件，在webpack.base.config.js中module.rules配置
		修改components目录中的Hello.vue文件的style标签 (<style lang='scss'><style>)
	54.vue修改打包后静态资源路径的修改
		我们只需要修改编译后的环境，所以只要修改prod.env.js下的build属性下的assetsPublicPath属性
		默认值是 "/" 根目录
		我这里加了一级 "/mywebsite/"
		最终页面上请求到的静态资源路径，比如css文件的地址就是：
		http://www.***.cn/mywebsite/static/css/index****.css

vuex常见面试题
	1.vuex是什么？怎么使用？哪种功能场景使用它？
		vue框架中状态管理。
		在main.js引入store，注入。
		场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
	2.vuex有哪几种属性
		state => 基本数据 
		getters => 从基本数据派生的数据 
		mutations => 提交更改数据的方法，同步！ 
		actions => 像一个装饰器，包裹mutations，使之可以异步。 
		modules => 模块化Vuex
	3.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
		如果您使用vuex的话，建议您存入vuex中，因为actions可以执行异步操作。同上，简单的页面放在methods里面即可。
		比较复杂，或者重要建议放在vuex中，容易维护，代码清晰,并且调用简单，这个在项目后期很重要。
	4.Vuex中如何异步修改状态
		在调用vuex中的方法action的时候，用promise实现异步修改
	5.Vuex中actions和mutations的区别
		action主要处理的是异步的操作，mutation必须同步执行，而action就不受这样的限制，也就是说action中我们既可以处理同步，
		也可以处理异步的操作
		action改变状态，最后是通过提交mutation

二.ES6面试题
	
ES6新增方法面试题
	1.let const var比较
		var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。
		let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
		const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。
		(全局作用域 函数作用域 块级作用域)
	2.反引号（`）标识
		普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
	3.函数默认参数
		 var f = function (a = 10,b = 10,c = 2a+b) {
            console.log(a+b)
            console.log(c)
         };
		f();
	4.箭头函数
		箭头函数this为父作用域的this，不是调用时的this
		箭头函数不能作为构造函数，不能使用new
		箭头函数返回对象时，要加一个小括号
		箭头函数没有arguments，caller，callee
		箭头函数通过call和apply调用，不会改变this指向，只会传入参数
		箭头函数没有原型属性
	5.属性简写
		同名的属性可以省略不写用"," 代替
	6.Object.keys()方法，获取对象的所有属性名或方法名
		用Object.keys()方法获取属性对应的值
		该方法可获得对象的属性名，返回一个数组
	7.import和export
		import语句用于导入由另一个模块导出的绑定。	
		用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，一边其他程序可以通过import语句使用它们。
	8.Promise对象
		promise是异步编程的一种解决方法。
		是一个构造函数，这个构造函数里有两个参数，分别是：resolve（成功之后的回调函数）、reject（失败之后的回调函数）。
		Pending：进行中
		Resolved(Fulfilled)：已完成
		Rejected：已失败
		所谓promise，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，
		从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，
		各种异步操作都可以用同样的方法进行处理。
	9.解构赋值
		let [a, b, c] = [1, 2, 3] // a=1, b=2, c=3
		let {a, b} = {a: 'aaaa', b: 'bbbb'} // a='aaaa' b='bbbb'
	10.set数据结构（可用于快速去重）
		类似于数组，但是成员的值都是唯一的，没有重复。Set本身是一个构造函数，用来生成Set数据结构
		const s = new Set();
		[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
	11.Spread Operator 展开运算符(...)
		(1).组装对象或者数组
			//数组
			const color = [ 'red' , 'yellow' ]
			const colorful = [...color, 'green' , 'pink' ]
			console.log(colorful)

			//对象
			const alp = { first:'a',second:'b' }
			const alphabets = { ...alp,third: 'c'}
			
ES6数组面试题
	1.forEach()
		forEach():遍历数组,并为每个元素调用传入的函数; 举例:
	2.map()
		方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
	3.filter()
		判断数组中是否存在某个值 方法返回一个新数组，
	4.reduce()
		reduce() 方法接收一个函数作为累加器,reduce 为数组中的每一个元素依次执行回调函数，
		不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组 
	5.some()
		方法用于检测数组中的元素是否满足指定条件（函数提供）。
		some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。
	6.every()
		方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。
		every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。
	7.all()方法
		Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

js面试题
	1.简述同步和异步的区别
		(1).同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。
		当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。
		(2).异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。
	3.Javascript中的七种主要数据类型
		Number、string、Object、Array、Boolean Null、Undefined
	3.如何判断数据类型
		typeof 
		console.log(
			typeof 123, //"number"
			typeof 'dsfsf', //"string"
			typeof false, //"boolean"
			typeof [1,2,3], //"object"
			typeof {a:1,b:2,c:3}, //"object"
			typeof function(){console.log('aaa');}, //"function"
			typeof undefined, //"undefined"
			typeof null, //"object"
			typeof new Date(), //"object"
			typeof /^[a-zA-Z]{5,20}$/, //"object"
			typeof new Error() //"object"
		);
	4.Js的事件委托是什么，原理是什么
		事件委托就是利用事件冒泡，只制定一个时间处理程序，就可以管理某一类型的所有事件
		优点： 1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。
				2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。
				3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。
		利用冒泡的原理，把事件加到父级上，触发执行效果。
	5.如何改变函数内部的this指针的指向
		(1).如果一个函数，是某个对象的key 值，那么，this就指向这个对象。 
		(2).如果函数new 了一下，那么就会创建一个对象，并且this 指向 新创建的对象。 
		(3).通过apply 可以改变this 的指向 
		javascript 的this 可以简单的认为是 后期绑定，没有地方绑定的时候，默认绑定window。 
	6.列举几种解决跨域问题的方式，且说明原理
		跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。
		(1).JSONP
			通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，
			在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，
			我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
			jsonp缺点：只能实现get一种请求。
		(2).代理
			服务器代理
		(3).PHP端修改header（XHR2方式）
	7.哪些操作会造成内存泄露？
		内存泄漏是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
		1.意外的全局变量引起的内存泄露
		2.闭包引起的内存泄露
		3.没有清理的DOM元素引用
		4.被遗忘的定时器或者回调
		5.子元素存在引起的内存泄露
		6.IE7/8引用计数使用循环引用产生的问题
	8.谈谈垃圾回收机制的方式及内存管理
		垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。
		JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，
		因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。
		合理的GC方案
		遍历所有可访问的对象。
		回收已不可访问的对象。
		和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑
	9.js实现继承的方法有哪些
		(1).es6中的继承使用Class来创建对象
		(2).原型式继承 :原型式继承主要的借助原型可以基于已有的对象创建新的对象，基本思想就是创建一个临时性的构造函数，
			然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例
		(3).借用构造函数 :子类型构造函数的内部调用超类型构造函数 该方法主要是通过apply()和call()方法
		(4).原型链继承:
	10.判断一个变量是否是数组，有哪些办法
		instanceof
		Array对象的 isArray方法
		Object.prototype.toString
	11.箭头函数与普通函数有什么区别
		相比普通函数更简洁的语法
		没有this
		不能使用new
		不绑定arguments，用rest参数...解决
		使用call()和apply()调用
		捕获其所在上下文的 this 值，作为自己的 this 值
		箭头函数没有原型属性
		不能简单返回对象字面量
		箭头函数不能当做Generator函数,不能使用yield关键字
		箭头函数不能换行
	12.new操作符具体干了什么
		(1).先创建了一个新的空对象
		(2).然后让这个空对象的__proto__指向函数的原型prototype
		(3).将对象作为函数的this传进去，如果return 出来东西是对象的话就直接返回 return 的内容，没有的话就返回创建的这个对象
	13.Ajax原理
		Ajax的工作原理相当于在用户和服务器之间加了―个中间层，使用户操作与服务器响应异步化。
		这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担，
		从而达到节约ISP的空间及带宽租用成本的目的。
		Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。
		简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。
	14.模块化开发怎么做
		全局函数
		对象封装--命名空间 
		私有公有成员分离
		模块的扩展与维护
	15.异步加载Js的方式有哪些
		异步加载又被称为非阻塞加载，浏览器在下载JS的同时，还会进行后续页面处理。
		Script Dom Element
		onload时的异步加载
		$(document).ready()
		<script>标签的async="async"属性
		<script>标签的defer="defer"属性
	16.xml和 json的区别
		xml扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、
		定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。
		JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。
		可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式
	17.webpack如何实现打包的
		webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。
		并不是什么commonjs或者amd之类的模块化规范。webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。
		至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。
		webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，
		所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)
	18.用过哪些设计模式
		MVC模式,在J2EE项目开发中主要用在表示层框架中，很好解决视图和流程控制。在项目中采用的Struts、WebWork等框架。
		DAO模式,在项目开发中主要用在数据层，封装数据的访问操作，为业务层提供数据服务。
		IoC模式,在项目开发中业务层有大量对象，他们之间存在依赖关系，可以使用IoC模式减少他们之间的代码耦合，
			提高系统的可扩展性。实际项目中使用的Spring框架来实现业务组件的装配。
		Observer模式，在Servlet的监听器中应用到了观察者模式。
		singleton单例模式和Factory工厂模式结合使用在项目中无需使用者了解过多的细节就可获取有关的对象实例。
			比如Hibernate项目中通过SessionFactory来获取Session。
		bridge模式，在项目中使用JDBC驱动访问数据库。
	19.为什么要同源限制
		同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。
		它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
		这里的同源指的是：同协议，同域名和同端口。
		在普通的Javascript应用中，我们可以修改Frame的href，或者IFrame的src，以实现GET方式的跨域提交，
		但是却不能访问跨域的Frame/IFrame中的内容。
	20.javascript有哪些方法定义对象
		基于已有对象扩充其属性和方法
		工厂方式new Object();
		构造函数方式this.username = "zhangsan";
		原型(“prototype”)方式
		动态原型方式 在构造函数中通过标志量让所有对象共享一个方法，而每个对象拥有自己的属性。
	21.说说你对promise的了解
		Promise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决 方案（回调函数和事件）更合理和更强大。 
		Promise对象的状态不受外界影响，有3个状态： 
			1）pending 初始状态 
			2）fulfilled 成功状态 
			3）rejected 失败状态
		Promise的状态一旦改变，就不会再变。 
		Promise,一旦新建，它就会立即执行，无法中途取消。 
		Promise如果不设置回调函数，Promise内部就会报错，不会反映到外部。 
		当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成。
	22.介绍js有哪些内置对象？
		Arguments 函数参数集合
		Array 数组
		Boolean 布尔对象
		Date 日期时间
		Error 异常对象
		Function 函数构造器
		Math 数学对象
		Number 数值对象
		Object 基础对象
		RegExp 正则表达式对象
		String 字符串对象
	23.说几条写JavaScript的基本规范？
		1.减少全局污染
		2.变量名的提升，应该在函数内部中所有使用var声明的变量都会提升到函数体头部。以免造成不必要的错误。
		3.for循环
			我们经常会把for()循环写成这种形式的。
			for(var i=0,;i<myarray.length;i++) 其实呢dom遍历是需要时间的，如果我们在数据很多的情况下也这样子写的话，
			这样子网页的性能就会变差，所以我们应该重复循环使用的是一开始遍历得到的结果myarray.length，
			把它保存在一个变量中，这样子我们就可以不用循环遍历再次进行操作了。
			for(var i=0,max=myarray.length;i<max;i++)
		4.用“===”取代"=="，前者是严格相等的意思，连数据类型也是需要相比较的，而后者提前会进行隐式的类型转换。
		5.花括号｛｝
			我们如果使用了for循环或者是if语句的话，我们都应该使用｛｝，即使是if后面的语句只有一行，我们也应该要使用｛｝。
		6.命名规则
			构造器函数首字母大写，如function Person(){}
		7.写注释。
		8.不要在同一个行内声明多个变量。
		9.Switch语句中必须带有default分支，
	24.eval是做什么的？
		把字符串参数解析成JS代码并运行，并返回执行的结果；	
	25.null 和undefined的区别？
		null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。
		undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。
	26.js延迟加载的方式有哪些？
		defer 属性 <script src="test1.js" defer="defer"></script>
		async 属性	<script src="test1.js" async></script>
		动态创建DOM方式: 这些代码应被放置在</body>标签前(接近HTML文件底部)
		使用jQuery的getScript方法
		使用setTimeout延迟方法
		让JS最后加载
	27.说说严格模式的限制
		变量必须声明后再使用
		函数的参数不能有同名属性，否则报错
		不能使用with语句
		不能对只读属性赋值，否则报错
		不能使用前缀0表示八进制数，否则报错
		不能删除不可删除的属性，否则报错
		不能删除变量delete prop，会报错，只能删除属性delete global[prop]
		eval不会在它的外层作用域引入变量
		eval和arguments不能被重新赋值
		arguments不会自动反映函数参数的变化
		不能使用arguments.callee
		不能使用arguments.caller
		禁止this指向全局对象
		不能使用fn.caller和fn.arguments获取函数调用的堆栈
		增加了保留字（比如protected、static和interface）
		设立"严格模式"的目的，主要有以下几个：
		消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
		消除代码运行的一些不安全之处，保证代码运行的安全；
		提高编译器效率，增加运行速度；
	28.常见兼容性问题
		不同浏览器的标签默认的margin和padding不同
		设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度
		块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
		图片默认有间距
		标签最低高度设置min-height不兼容
		各种特殊样式的兼容，比如透明度、圆角、阴影等。特殊样式每个浏览器的代码区别很大，所以，
		只能现查资料通过给不同浏览器写不同的代码来解决。
	29.原始类型有哪几种？null是对象吗？
		undefined、null、string、number、boolean、symbol(es6新增)
		null其实并不是一个对象，尽管typeof null 输出的是object,但是这其实是一个bug。在js最初的版本中使用的是32位系统，
		为了性能考虑地位存储变量的类型信息，000开头表示为对象类型，然而null为全0，故而null被判断为对象类型。
	30.如何判断this？箭头函数的this是什么
		箭头函数：出现的作用除了让函数的书写变得很简洁，可读性很好外；最大的优点是解决了this执行环境所造成的一些问题。
		比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题。
		谁调用函数 谁就是this
	31.== 和 ===的区别
		== 表示相等 （值相等）
		===表示恒等（类型和值都要相等）
		js在比较的时候如果是 == 会先做类型转换，再判断值得大小，如果是===类型和值必须都相等。
	32.什么是闭包
		简单讲，闭包就是指有权访问另一个函数作用域中的变量的函数。
		它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。
		外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。
	33.JavaScript原型，原型链 ? 有什么特点？
		原型:JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。
		原型链:简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，
			原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，
			当向上找找到Object的原型的时候，这条原型链就算到头了。
	34.typeof()和instanceof()的用法区别
		typeof（） 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。
		instanceof 用于判断一个变量是否某个对象的实例，如var a=new Array();alert(a instanceof Array);
		会返回true，同时alert(a instanceof Object)也会返回true;这是因为Array是object的子类
	35.ES6新的特性有哪些？
		不一样的变量声明：const和let
		模板字符串
		箭头函数（Arrow Functions）
		函数的参数默认值
		Spread / Rest 操作符
		二进制和八进制字面量
		对象和数组解构
		对象超类
		for…of 和 for…in
		ES6中的类
	36.promise 有几种状态, Promise 有什么优缺点 ?
		* pending：初始状态，既不是成功也不是失败
		* fulfilled：意味着操作完全成功
		* rejected：意味着操作失败
		Promise对象的缺点：
		1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。
		2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
		3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
		4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。
		Promise对象的优点：
		promise主要解决回调地狱问题
		使得原本的多层级的嵌套代码，变成了链式调用
		让代码更清晰，减少嵌套数
	37.Promise构造函数是同步还是异步执行，then呢 ?promise如何实现then处理 ?
		异步执行
	38.Promise和setTimeout的区别 ?
		promise比settimeout先执行的
		原因：promise的任务会在当前事件循环末尾中执行，而settimeout中的任务是在下一次事件循环中执行。
		所以异步操作不是一个新事件添加到事件循环队列，而是就在当前任务队里末尾添加。
		这里的promise异步操作就添加到了当前任务队的末尾了，而settimeout则是下一个事件中的任务了。
	39.如何实现 Promise.all ?
		Promise.all()接收一个数组为参数，当数组的所有Promise都为resolve的状态时，Promise.all()才会成功；
		若有一个失败，都会被认为是失败的。
	40.如何实现 Promise.finally ?
		不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。
	41.如何判断img加载完成
		load事件
			$('img').onload = function() {
			//code
			}
		readystatechange事件
			img.onreadystatechange = function() {
				if(img.readyState=="complete"||img.readyState=="loaded"){ 
					p.innerHTML = 'readystatechange:loaded'
				}
			}
		img的complete属性
		function imgLoad(img, callback) {
			var timer = setInterval(function() {
				if (img.complete) {
					callback(img)
					clearInterval(timer)
				}
			}, 50)
			}
			imgLoad(img1, function() {
			p1.innerHTML('加载完毕')
		})
	42.如何阻止冒泡？
		// 阻止浏览器的默认行为
		window.event? window.event.returnValue=false :e.preventDefault();

		//停止事件冒泡
		window.event?window.event.cancelBubble=true:e.stopPropagation();
	43.ajax请求时，如何解释json数据
		json是一种轻量级交互格式,本质上都是字符串,常用于前后端的数据交互,本质上就是字符串.
		前端在解析后端发来的数据,使用JSON.parse()方法把字符串转为json对象.
		前端在向后端发送数据,使用JSON.stringify()方法把json对象转为字符串. 
	44. json和jsonp有什么差异？
		json返回的是一串数据；而jsonp返回的是脚本代码（包含一个函数调用）；
		JSON其实就是JavaScript中的一个对象，json其实就是JavaScript中的对象(Object)和数组(Array，其实也是对象)相互嵌套，
		以此模拟出许多复杂的数据结构。
		jsonp全名叫做json with padding，很形象，就是把json对象用符合js语法的形式包裹起来以使其它网站可以请求得到，
		也就是将json数据封装成js文件；
		json是理想的数据交换格式，但没办法跨域直接获取，于是就将json包裹(padding)在一个合法的js语句中作为js文件传过去。
		这就是json和jsonp的区别，json是想要的东西，jsonp是达到这个目的而普遍采用的一种方法，当然最终获得和处理的还是json。所以说json是目的，jsonp只是手段。json总会用到，而jsonp只有在跨域获取数据才会用到。
		json和jsonp虽然只有一个字母的区别，但是它们之间扯不上关系。 json是一种轻量级的数据交换格式。
		jsonp是一种跨域数据交互协议。 
		json的优点：（1）基于纯文本传递极其简单，（2）轻量级数据格式适合互联网传递，（3）容易编写和解析。
	45.浏览器是如何渲染页面的？
		处理HTML标记并构建DOM树
		处理CSS标记并构建CSSOM树
		将DOM与CSSOM合并成一个渲染树
		根据渲染树来布局，计算每个节点的布局信息
		将各个节点绘制到屏幕上
	46.XMLHttpRequest：XMLHttpRequest.readyState;状态码的意思
		1**	信息，服务器收到请求，需要请求者继续执行操作
		2**	成功，操作被成功接收并处理
		3**	重定向，需要进一步的操作以完成请求
		4**	客户端错误，请求包含语法错误或无法完成请求
		5**	服务器错误，服务器在处理请求的过程中发生了错误
	47.http请求的状态吗
		1**	信息，服务器收到请求，需要请求者继续执行操作
		2**	成功，操作被成功接收并处理
		3**	重定向，需要进一步的操作以完成请求
		4**	客户端错误，请求包含语法错误或无法完成请求
		5**	服务器错误，服务器在处理请求的过程中发生了错误
	48.document.write和innerHTML的区别
		执行结果显示：document.write会将页面上的所有内容清除包括标题。
		执行结果显示：innerHTML只会重写所属元素的内容，即<div>元素中的内容。

浏览器/html/css面试题
	1.什么是盒模型
		在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），
		元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，
		而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。
	2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？
		行内元素：a、b、span、img、input、strong、select、label、em、button、textarea
		块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote
		空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img
		行内元素不可以设置宽高，不独占一行;
		块级元素可以设置宽高，独占一行。
	3.简述src和href的区别
		src 是指向物件的来源地址，是引入。在 img、script、iframe 等元素上使用。
		href 是超文本引用，指向需要连结的地方，是与该页面有关联的，是引用。在 link和a 等元素上使用。
	4.什么是css Hack
		CSS hack：由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，
		或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，
		得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，
		能在不同的浏览器中也能得到我们想要的页面效果。
	5.什么叫优雅降级和渐进增强
		优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，
		则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,
		为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.
		渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,
		向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
	6.px和em和rem的区别
		(1).PX是Pixel的缩写，也就是说像素是指基本原色素及其灰度的基本编码，
		由 Picture(图像) 和 Element（元素）这两个单词的字母所组成的，如同摄影的相片一样，数码影像也具有连续性的浓淡阶调。
		若把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”。
		(2).em单位名称为相对长度单位。相对于当前对象内文本的字体尺寸，国外使用比较多。
		<em>(emphasize) 标签告诉浏览器把其中的文本表示为强调的内容。对于所有浏览器来说，这意味着要把这段文字用斜体来显示。
		(3).REM是相对单位，是相对HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，
		通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。
		目前，除了IE8及更早版本外，所有浏览器均已支持rem。
	7.一次完整的HTTP事务是怎么一个过程
		域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，
		浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 
		浏览器对页面进行渲染呈现给用户
	8.HTTPS是如何实现加密
		1，服务端生成jks文件，并导出只含公钥的ser文件给服务端
		2，客户端用ser文件生成自己的bks文件，用来验证服务端的消息
		3，客户端自己生成pfx文件，并导出只含公钥的ser文件给服务端
		4，服务端用客户端的ser文件进行验证来自客户端的消息
	9.浏览器是如何渲染页面的？
		处理HTML标记并构建DOM树
		处理CSS标记并构建CSSOM树
		将DOM与CSSOM合并成一个渲染树
		根据渲染树来布局，计算每个节点的布局信息
		将各个节点绘制到屏幕上
	10.浏览器的内核有哪些？分别有什么代表的浏览器
		Trident内核：IE最先开发或使用的，也称IE内核，360浏览器使用的也是IE内核；
		Webkit内核：谷歌chrome浏览器最先开发或使用，也叫谷歌内核，枫树浏览器、太阳花使用的也是谷歌内核；
		Gecko内核： Netscape6开始采用的内核，后来的Mozilla FireFox (火狐浏览器) 也采用了该内核，K-Meleon浏览器也是使用这种内核；
		Presto内核：目前只有Opera浏览器采用该内核
	11.页面载入时，link和@import有什么区别？
	   （1）link属于xhtml标签，除了加载css之外，还能用于定义RSS,定义rel连接属性等作用而@import是css提供的只用于加载css
	   （2）页面加载时，link会同时被加载；@import引用css会等页面加载完毕之后在加载
	   （3）@import只有ie5以上浏览器才兼容，而link属于xhtml无兼容问题
	12.列举你了解Html5. Css3 新特性
		html5:
		用于绘画的 canvas 元素
		用于媒介回放的 video 和 audio 元素
		对本地离线存储的更好的支持
		新的特殊内容元素，比如 article、footer、header、nav、section
		新的表单控件，比如 calendar、date、time、email、url、search
		css3:
		CSS3实现圆角（border-radius），阴影（box-shadow），
		对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
		transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
		增加了更多的CSS选择器  多背景 rgba 
		在CSS3中唯一引入的伪元素是 ::selection.
		媒体查询，多栏布局
		border-image
	13.列举几个前端性能方面的优化
		使用CDN
		减少外部http协议
		使用预获取
		压缩HTML、CSS和JavaScript
		优化图片
		Ajax请求方式
	14.如何实现同一个浏览器多个标签页之间的通信
		websocket通讯
			WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，
			服务器可以在任意时刻发送消息给浏览器。为什么传统的HTTP协议不能做到WebSocket实现的功能？
			这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，
			再把数据发送给浏览器。
		定时器setInterval+cookie
			在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。
		使用localstorage
			localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，
			每个标签页都是单独的）。
		html5浏览器的新特性SharedWorker
			普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。
			然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。
	15.浏览器的存储技术有哪些
		LocalStorage
			 localStorage是什么：在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，
			 解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，
			 这个在不同的浏览器中localStorage会有所不同。
			 localStorage的优点：
				1）localStorage拓展了cookie的4K限制；
				2）localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，
				相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的；
				3）localStorage 方法存储的数据没有时间限制。第二天、第二
				周或下一年之后，数据依然可用。
			 localStorage的缺点：
				1）浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性；
				2）目前所有的浏览器中都会把localStorage的值类型限定为string类型，
				这个在对我们日常比较常见的JSON对象类型需要一些转换；
				3）localStorage在浏览器的隐私模式下面是不可读取的；
				4）localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡；
				5）localStorage不能被爬虫抓取到。
		SessionStorage
			sessionStorage与localStorage的唯一一点区别就是localStorage属于永久性存储，
			而sessionStorage属于当会话结束的时候，sessionStorage中的键值对就会被清空。
		Cookie
			cookie是什么：cookie是指存储在用户本地终端上的数据，同时它是与具体的web页面或者站点相关的。
				cookie数据会自动在web浏览器和web服务器之间传输，也就是说HTTP请求发送时，
				会把保存在该请求域名下的所有cookie值发送给web服务器，因此服务器端脚本是可以读、
				写存储在客户端的cookie的操作。
			cookie的有效期：cookie默认情况下的有效期是很短暂的，一旦用户关闭浏览器，cookie保存的数据就会丢失。
				如果想要延长cookie的有效期，可以通过设置HTTP头信息中的cache-control属性的max-age值，
				或者修改HTTP头信息中的expires属性的值来延长有效期。
			cookie的优点：能用于和服务器端通信；当cookie快要过期时，可以重新设置而不是删除。
			cookie的缺点：它会随着http头信息一起发送，增加了网络流量（文档传输的负载）；
				它只能储存少量的数据；它只能储存字符串；有潜在的安全问题。
	16.css定位方式
		static（静态定位）：
			默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）
		relative（相对定位）：
			定位为relative的元素脱离正常的文档流，但其在文档流中的位置依然存在，只是视觉上相对原来的位置有移动。
　　		通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级 。
		absolute（绝对定位）
			生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 
			以及 "bottom" 属性进行规定。可通过z-index进行层次分级。
		fixed（固定定位）：
			生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 
			属性进行规定。可通过z-index进行层次分级
	17.尽可能多的写出浏览器兼容性问题
		不同浏览器的标签默认的外补丁和内补丁不同(随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。)
		块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
		设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度
		行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug
		图片默认有间距
		标签最低高度设置min-height不兼容
		透明度的兼容CSS设置
	18.垂直上下居中的方法
		绝对定位方法：不确定当前div的宽度和高度，采用 transform: translate(-50%,-50%); 当前div的父级添加相对定位（position: relative;）
		绝对定位方法：确定了当前div的宽度，margin值为当前div宽度一半的负值	
		绝对定位方法：绝对定位下top left right bottom 都设置0
		flex布局方法：当前div的父级添加flex css样式
		table-cell实现水平垂直居中: table-cell middle center组合使用
		绝对定位：calc() 函数动态计算实现水平垂直居中
	19.响应式布局原理
		意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。
		设置viewport
		媒体查询
		字体的适配（字体单位）
		百分比布局
		图片的适配（图片的响应式）
		结合flex，grid，BFC，栅格系统等已经成型的方案
	20.清除浮动的方法
		父级div定义伪类：after和zoom
		在结尾处添加空div标签clear:both
		父级div定义height
		父级div定义overflow:hidden
		父级div定义overflow:auto
		父级div也一起浮动
		父级div定义display:table
		结尾处加br标签clear:both
	21.http协议和tcp协议
		TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。Http协议是建立在TCP协议基础之上的，
		当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道。
		简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，
		如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，
		它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。Http是无状态的短连接，
		而TCP是有状态的长连接
	22.刷新页面，js请求一般会有哪些地方有缓存处理
		DNS缓存：短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器。
		CDN缓存：内容分发网络（人们可以在就近的代售点取火车票了，不用非得到火车站去排队）
		浏览器缓存：浏览器在用户磁盘上，对最新请求过的文档进行了存储。
		服务器缓存：将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。
	23.如何对网站的文件和资源进行优化
		1.文件合并（目的是减少http请求）：使用css sprites合并图片，一个网站经常使用小图标和小图片进行美化，
			但是很遗憾这些小图片占用了大量的HTTP请求，因此可以采用sprites的方式把所有的图片合并成一张图片 ，
			可以通过相关工具在线合并，也可以在ps中合并。
		2.使用CDN（内容分发网络）加速，降低通信距离。
		3.缓存的使用，添加Expire/Cache-Control头。
		4.启用Gzip压缩文件。
		5.将css放在页面最上面。
		6.将script放在页面最下面。
		7.避免在css中使用表达式。
		8.将css, js都放在外部文件中。
		9.减少DNS查询。
		10.文件压缩：最小化css, js，减小文件体积。
		11.避免重定向。
		12.移除重复脚本。
		13.配置实体标签ETag。
		14.使用AJAX缓存，让网站内容分批加载，局部更新。
	24.你对网页标准和W3C重要性的理解
		(1)Web标准规范要求，书写标签必须闭合、标签小写、不乱嵌套，可提高搜索机器人对网页内容的搜索几率。
		(2)建议使用外链css和js脚本，从而达到结构与行为、结构与表现的分离，提高页面的渲染速度，能更快地显示页面的内容。
			Web前端面试题：谈谈你对Web标准的理解，以及对w3c组织的认识？
		(3)样式与标签的分离，更合理的语义化标签，使内容能被更多的用户所访问、内容能被更广泛的设备所访问、
			更少的代码和组件， 从而降低维护成本、改版更方便 。
		(4)不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性 遵循w3c制定的Web标准，
			能够使用户浏览者更方便的阅读，使网页开发者之间更好的交流。
	25.Http和https的区别
		1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
		2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
		3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
		4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
		HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），
			用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
		HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，
			因此加密的详细内容就需要SSL。
	26.data-属性的作用
		data-为H5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，
			不支持该属性的浏览器可以通过 getAttribute 方法获取 :
		需要注意的是：data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。 
			所有主流浏览器都支持 data-* 属性。
	27.如何让Chrome浏览器显示小于12px的文字
		transform:scale()，缩放 CSS3
	28.哪些操作会引起页面回流（Reflow）
		reflow(回流)是指浏览器为了重新渲染部分或者全部的文档,重新计算文档中的元素的位置和几何构造的过程。
		因为回流可能导致整个Dom树的重新构造,所以是性能的一大杀手。
		以下操作会引起回流：
		① 改变窗口大小
		② font-size大小改变
		③ 增加或者移除样式表
		④ 内容变化（input中输入文字会导致）
		⑤ 激活CSS伪类（:hover）
		⑥ 操作class属性，新增或者减少
		⑦ js操作dom
		⑧ offset相关属性计算
		⑨ 设置style的值
	29.如何实现页面每次打开时清除本页缓存
		用HTML标签设置HTTP头信息
			<meta http-equiv="Pragma" content="no-cache">
			header("Cache-Control: no-cache, must-revalidate")
			<meta http-equiv="Cache-Control" content="no-cache">
			<meta http-equiv="Expires"  content="0">
		HTTP头信息“Expires”和“Cache-Control”为应用程序服务器提供了一个控制浏览器和代理服务器上缓存的机制。
		HTTP头信息Expires告诉代理服务器它的缓存页面何时将过期。
		HTTP1.1规范中新定义的头信息Cache-Control可以通知浏览器不缓存任何页面。
		当点击后退按钮时，浏览器重新访问服务器已获取页面。
	30.伪元素和伪类的区别
		伪类存在的意义是为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的信息。
		 :first-child 匹配第一个子元素。
		 :last-child 匹配最后一个子元素。
		 :first-of-type 匹配属于其父元素的第一个特定类型的子元素。
		 伪元素可以创建一些文档语言无法创建的虚拟元素。比如：文档语言没有一种机制可以描述元素内容的第一个字母或第一行，
		 但伪元素可以做到(::first-letter、::first-line)。同时，伪元素还可以创建源文档不存在的内容，
		 比如使用 ::before 或 ::after。
	31.http的几种请求方法和区别
		GET  	请求指定的页面信息，并返回实体主体。
		HEAD 	类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
		POST 	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。
					数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
		PUT  	从客户端向服务器传送的数据取代指定的文档的内容。
		DELETE  请求服务器删除指定的页面。
		CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
		OPTIONS 允许客户端查看服务器的性能。
		TRACE 	回显服务器收到的请求，主要用于测试或诊断。
		PATCH	实体中包含一个表，表中说明与该URI所表示的原内容的区别。
		MOVE 	请求服务器将指定的页面移至另一个网络地址。
		COPY	请求服务器将指定的页面拷贝至另一个网络地址。
		LINK	请求服务器建立链接关系。
		UNLINK	断开链接关系。
		WRAPPED	允许客户端发送经过封装的请求。
		Extension-mothed	在不改动协议的前提下，可增加另外的方法。
	32.前端需要注意哪些SEO
		SEO具体是指通过网站结构调整、网站内容建设、网站代码优化、以及站外优化（网站站外推广、网站品牌建设等），
		使网站满足搜索引擎的收录排名需求，提高网站在搜索引擎中关键字的排名，从而吸引精准用户进入网站，获得免费流量，
		产生直接销售或品牌推广。
			1、 合理的title，description，keyswords 搜索引擎对这三项的权重逐个减小，title 值强调重点即可，重要的关键
				词出现不要超过两次，而且要靠前。
			2 、不同页面的tilte要有所不同；description把页面的内容高度概括，长度合适，不可过分堆叠关键词，不同页面
				description有所不同。keyswords列举出重要的关键词即可。
			3、语义化的HTML代码，符合W3C 规范：语义化代码有利于搜索引擎理解网页。
			4 、重要的内容HTML代码放在前面：搜索引擎抓取HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，保
				证重要内容一定会被抓取。
			5 、重要的内容不要用js输出，爬虫不会执行js获取内容。
			6 、尽量少用iframe ，搜索引擎不会抓取iframe中的内容。
			7 、非装饰的图片必须加alt 。
			8 、提高网站速度：网站速度是搜索引擎排序的一个重要指标。
	33.的title和alt有什么区别
		Alt是<img>的特有属性，是图片内容的等价描述，用于图片无法加载时显示，读屏器阅读图片。
		title   可提高图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。
			鼠标滑过时显示的文字提示，用户体验上很重要。当然不必要所有的img标签都加此属性，
			比方说logo这样比较重要或者说用户会体验到的图片内容建议一定要加此属性。
	34.从浏览器地址栏输入url到显示页面的步骤
		1.域名解析
		2.TCP连接
			HTTP协议是使用TCP协议作为其传输层协议的，在拿到服务器的IP地址后，浏览器客户端会与服务器建立TCP连接。
			该过程包括三次握手：
			第一次握手：建立连接时，客户端向服务端发送请求报文
			第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文
			第三次握手，客户端收到服务器的确认后，再次向服务器给出确认报文，完成连接。
			三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。
		3.浏览器发送HTTP请求
		4、服务器处理HTTP请求
		5、浏览器页面渲染
		6、断开TCP连接
			第四次挥手：客户端发送消息给服务器，确定分手，服务器关闭连接
	35.如何进行网站性能优化
		减少HTTP 请求数――――最重要最有效的方法
		外部脚本置底 
		异步执行inline脚本 
		Lazy Load Javascript 
		将 CSS放在head中 
		减少不必要的 HTTP跳转 
		避免重复的资源请求 
	36.语义化的理解
		1、去掉或者丢失样式的时候能够让页面呈现出清晰的结构；
		2、有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
		3、方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
		4、便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
	37.HTML5的离线储存怎么使用，工作原理能不能解释一下？
		原理：HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，
		这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。
	38.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢
		在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，
		那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，
		那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，
		就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。
	39.iframe有那些缺点？
		iframe的优点：
		1.iframe能够原封不动的把嵌入的网页展现出来。
		2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
		3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
		4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。
		iframe的缺点：
		1.会产生很多页面，不容易管理。
		2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
		3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
		4.很多的移动设备（PDA手机）无法完全显示框架，设备兼容性差。
		5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。
		现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。
	40.WEB标准以及W3C标准是什么?
		标签闭合
		标签小写
		嵌套正确
		外部链接css和js
		提倡结构、表现和行为相分离（HTML结构、CSS表现、JavaScript行为）
	41.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?
		

	
